{"dependencies":[{"name":"../engine","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":17,"column":0,"index":703},"end":{"line":17,"column":35,"index":738}}],"key":"zbTTi8rtwr8rjl75PzEo829Yvss=","exportNames":["*"],"imports":1}},{"name":"../kernel_names","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":18,"column":0,"index":739},"end":{"line":18,"column":43,"index":782}}],"key":"gQVznmdGA0uoBQvR5Q4/qW+ITHg=","exportNames":["*"],"imports":1}},{"name":"../tensor_util_env","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":19,"column":0,"index":783},"end":{"line":19,"column":53,"index":836}}],"key":"UCKDOr/oOGi3nbD26ZhyAVW61qk=","exportNames":["*"],"imports":1}},{"name":"./operation","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":20,"column":0,"index":837},"end":{"line":20,"column":33,"index":870}}],"key":"lmmEAb6oR3TWnrsrETceKUovfkM=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"gatherND\", {\n    enumerable: true,\n    get: function () {\n      return gatherND;\n    }\n  });\n  var _engine = require(_dependencyMap[0], \"../engine\");\n  var _kernel_names = require(_dependencyMap[1], \"../kernel_names\");\n  var _tensor_util_env = require(_dependencyMap[2], \"../tensor_util_env\");\n  var _operation = require(_dependencyMap[3], \"./operation\");\n  /**\n   * @license\n   * Copyright 2018 Google LLC. All Rights Reserved.\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   * =============================================================================\n   */\n\n  /**\n   * Gather slices from input tensor into a Tensor with shape specified by\n   * `indices`.\n   *\n   * `indices` is a K-dimensional integer tensor, best thought of as a\n   * (K-1)-dimensional tensor of indices into input, where each element defines a\n   * slice of input:\n   * output[\\\\(i_0, ..., i_{K-2}\\\\)] = input[indices[\\\\(i_0, ..., i_{K-2}\\\\)]]\n   *\n   * Whereas in `tf.gather`, `indices` defines slices into the first dimension of\n   * input, in `tf.gatherND`, `indices` defines slices into the first N dimensions\n   * of input, where N = indices.shape[-1].\n   *\n   * The last dimension of indices can be at most the rank of input:\n   * indices.shape[-1] <= input.rank\n   *\n   * The last dimension of `indices` corresponds to elements\n   * (if indices.shape[-1] == input.rank) or slices\n   * (if indices.shape[-1] < input.rank) along dimension indices.shape[-1] of\n   * input.\n   * The output tensor has shape\n   * indices.shape[:-1] + input.shape[indices.shape[-1]:]\n   *\n   * Note that on CPU, if an out of bound index is found, an error is returned. On\n   * GPU, if an out of bound index is found, a 0 is stored in the corresponding\n   * output value.\n   *\n   * ```js\n   * const indices = tf.tensor2d([0, 1, 1, 0], [2,2], 'int32');\n   * const input = tf.tensor2d([9, 10, 11, 12], [2, 2]);\n   * tf.gatherND(input, indices).print() // [10, 11]\n   * ```\n   *\n   * @param x The tensor from which to gather values.\n   * @param indices Index tensor, must be of type int32.\n   *\n   * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n   */\n  function gatherND_(x, indices) {\n    const $indices = (0, _tensor_util_env.convertToTensor)(indices, 'indices', 'gatherND', 'int32');\n    const $x = (0, _tensor_util_env.convertToTensor)(x, 'x', 'gatherND', 'string_or_numeric');\n    const inputs = {\n      params: $x,\n      indices: $indices\n    };\n    return _engine.ENGINE.runKernel(_kernel_names.GatherNd, inputs);\n  }\n  const gatherND = /* @__PURE__ */(0, _operation.op)({\n    gatherND_\n  });\n});","lineCount":84,"map":[[7,2,65,0,"Object"],[7,8,65,0],[7,9,65,0,"defineProperty"],[7,23,65,0],[7,24,65,0,"exports"],[7,31,65,0],[8,4,65,0,"enumerable"],[8,14,65,0],[9,4,65,0,"get"],[9,7,65,0],[9,18,65,0,"get"],[9,19,65,0],[10,6,65,0],[10,13,65,0,"gatherND"],[10,21,65,0],[11,4,65,0],[12,2,65,0],[13,2,17,0],[13,6,17,0,"_engine"],[13,13,17,0],[13,16,17,0,"require"],[13,23,17,0],[13,24,17,0,"_dependencyMap"],[13,38,17,0],[14,2,18,0],[14,6,18,0,"_kernel_names"],[14,19,18,0],[14,22,18,0,"require"],[14,29,18,0],[14,30,18,0,"_dependencyMap"],[14,44,18,0],[15,2,19,0],[15,6,19,0,"_tensor_util_env"],[15,22,19,0],[15,25,19,0,"require"],[15,32,19,0],[15,33,19,0,"_dependencyMap"],[15,47,19,0],[16,2,20,0],[16,6,20,0,"_operation"],[16,16,20,0],[16,19,20,0,"require"],[16,26,20,0],[16,27,20,0,"_dependencyMap"],[16,41,20,0],[17,2,1,0],[18,0,2,0],[19,0,3,0],[20,0,4,0],[21,0,5,0],[22,0,6,0],[23,0,7,0],[24,0,8,0],[25,0,9,0],[26,0,10,0],[27,0,11,0],[28,0,12,0],[29,0,13,0],[30,0,14,0],[31,0,15,0],[32,0,16,0],[34,2,21,0],[35,0,22,0],[36,0,23,0],[37,0,24,0],[38,0,25,0],[39,0,26,0],[40,0,27,0],[41,0,28,0],[42,0,29,0],[43,0,30,0],[44,0,31,0],[45,0,32,0],[46,0,33,0],[47,0,34,0],[48,0,35,0],[49,0,36,0],[50,0,37,0],[51,0,38,0],[52,0,39,0],[53,0,40,0],[54,0,41,0],[55,0,42,0],[56,0,43,0],[57,0,44,0],[58,0,45,0],[59,0,46,0],[60,0,47,0],[61,0,48,0],[62,0,49,0],[63,0,50,0],[64,0,51,0],[65,0,52,0],[66,0,53,0],[67,0,54,0],[68,0,55,0],[69,0,56,0],[70,0,57,0],[71,0,58,0],[72,2,59,0],[72,11,59,9,"gatherND_"],[72,20,59,18,"gatherND_"],[72,21,59,19,"x"],[72,22,59,20],[72,24,59,22,"indices"],[72,31,59,29],[72,33,59,31],[73,4,60,4],[73,10,60,10,"$indices"],[73,18,60,18],[73,21,60,21],[73,25,60,21,"convertToTensor"],[73,41,60,36],[73,42,60,36,"convertToTensor"],[73,57,60,36],[73,59,60,37,"indices"],[73,66,60,44],[73,68,60,46],[73,77,60,55],[73,79,60,57],[73,89,60,67],[73,91,60,69],[73,98,60,76],[73,99,60,77],[74,4,61,4],[74,10,61,10,"$x"],[74,12,61,12],[74,15,61,15],[74,19,61,15,"convertToTensor"],[74,35,61,30],[74,36,61,30,"convertToTensor"],[74,51,61,30],[74,53,61,31,"x"],[74,54,61,32],[74,56,61,34],[74,59,61,37],[74,61,61,39],[74,71,61,49],[74,73,61,51],[74,92,61,70],[74,93,61,71],[75,4,62,4],[75,10,62,10,"inputs"],[75,16,62,16],[75,19,62,19],[76,6,62,21,"params"],[76,12,62,27],[76,14,62,29,"$x"],[76,16,62,31],[77,6,62,33,"indices"],[77,13,62,40],[77,15,62,42,"$indices"],[78,4,62,51],[78,5,62,52],[79,4,63,4],[79,11,63,11,"ENGINE"],[79,18,63,17],[79,19,63,17,"ENGINE"],[79,25,63,17],[79,26,63,18,"runKernel"],[79,35,63,27],[79,36,63,28,"GatherNd"],[79,49,63,36],[79,50,63,36,"GatherNd"],[79,58,63,36],[79,60,63,38,"inputs"],[79,66,63,44],[79,67,63,45],[80,2,64,0],[81,2,65,7],[81,8,65,13,"gatherND"],[81,16,65,21],[81,19,65,24],[81,34,65,40],[81,38,65,40,"op"],[81,48,65,42],[81,49,65,42,"op"],[81,51,65,42],[81,53,65,43],[82,4,65,45,"gatherND_"],[83,2,65,55],[83,3,65,56],[83,4,65,57],[84,0,65,58],[84,3]],"functionMap":{"names":["<global>","gatherND_"],"mappings":"AAA;AC0D;CDK"},"hasCjsExports":false},"type":"js/module"}]}