{"dependencies":[{"name":"../engine","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":17,"column":0,"index":703},"end":{"line":17,"column":35,"index":738}}],"key":"zbTTi8rtwr8rjl75PzEo829Yvss=","exportNames":["*"],"imports":1}},{"name":"../kernel_names","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":18,"column":0,"index":739},"end":{"line":18,"column":54,"index":793}}],"key":"gQVznmdGA0uoBQvR5Q4/qW+ITHg=","exportNames":["*"],"imports":1}},{"name":"../tensor_util_env","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":19,"column":0,"index":794},"end":{"line":19,"column":53,"index":847}}],"key":"UCKDOr/oOGi3nbD26ZhyAVW61qk=","exportNames":["*"],"imports":1}},{"name":"./operation","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":20,"column":0,"index":848},"end":{"line":20,"column":33,"index":881}}],"key":"lmmEAb6oR3TWnrsrETceKUovfkM=","exportNames":["*"],"imports":1}},{"name":"./scatter_nd_util","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":21,"column":0,"index":882},"end":{"line":21,"column":53,"index":935}}],"key":"Uml/2U9tiYfGY2BTXe9gKWBGYrk=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = {};\n    if (e) Object.keys(e).forEach(function (k) {\n      var d = Object.getOwnPropertyDescriptor(e, k);\n      Object.defineProperty(n, k, d.get ? d : {\n        enumerable: true,\n        get: function () {\n          return e[k];\n        }\n      });\n    });\n    n.default = e;\n    return n;\n  }\n  Object.defineProperty(exports, \"tensorScatterUpdate\", {\n    enumerable: true,\n    get: function () {\n      return tensorScatterUpdate;\n    }\n  });\n  var _engine = require(_dependencyMap[0], \"../engine\");\n  var _kernel_names = require(_dependencyMap[1], \"../kernel_names\");\n  var _tensor_util_env = require(_dependencyMap[2], \"../tensor_util_env\");\n  var _operation = require(_dependencyMap[3], \"./operation\");\n  var _scatter_nd_util = require(_dependencyMap[4], \"./scatter_nd_util\");\n  var scatter_nd_util = _interopNamespace(_scatter_nd_util);\n  /**\n   * @license\n   * Copyright 2022 Google LLC. All Rights Reserved.\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   * =============================================================================\n   */\n\n  /**\n   * Creates a new tensor by applying sparse updates to individual\n   * values or slices to the passed in tensor according to\n   * indices. This operator is the similar to scatterNd op, except that the\n   * udpates are scattered on an existing tensor (as opposed to a zero-tensor).\n   *\n   * If indices contains duplicates, then we pick the last update for the index.\n   *\n   * If an out of bound index is found on CPU, an error is returned.\n   *\n   * Warning: There are some GPU specific semantics for this operation.\n   *  - If an out of bound index is found, the index is ignored.\n   *  - The order in which updates are applied is nondeterministic, so the output\n   * will be nondeterministic if indices contains duplicates.\n   * ```js\n   * const shape = [8];\n   * const tensor = tf.ones(shape);\n   * const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');\n   * const updates = tf.tensor1d([9, 10, 11, 12]);\n   *\n   * tf.tensorScatterUpdate(tensor, indices, updates).print();\n   *    //[1, 11, 1, 10, 9, 1, 1, 12]\n   * ```\n   *\n   * @param tensor A Tensor. Tensor to copy/update.\n   * @param indices The tensor contains the indices into the output tensor, must\n   *     have at least 2 axes: (num_updates, index_depth).\n   * @param updates The tensor contains the value for the indices.\n   *\n   * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n   */\n  function tensorScatterUpdate_(tensor, indices, updates) {\n    const $tensor = (0, _tensor_util_env.convertToTensor)(tensor, 'tensor', 'tensorScatterupdate');\n    const $indices = (0, _tensor_util_env.convertToTensor)(indices, 'indices', 'tensorScatterupdate', 'int32');\n    const $updates = (0, _tensor_util_env.convertToTensor)(updates, 'updates', 'tensorScatterupdate');\n    scatter_nd_util.validateInput($updates, $indices, $tensor.shape);\n    if ($tensor.dtype !== $updates.dtype) {\n      throw new Error(`tensor and updates must have the same dtype, instead they are ${$tensor.dtype} and ${$updates.dtype}.`);\n    }\n    const inputs = {\n      tensor: $tensor,\n      indices: $indices,\n      updates: $updates\n    };\n    const attrs = {};\n    // tslint:disable-next-line: no-unnecessary-type-assertion\n    return _engine.ENGINE.runKernel(_kernel_names.TensorScatterUpdate, inputs, attrs);\n  }\n  const tensorScatterUpdate = (0, _operation.op)({\n    tensorScatterUpdate_\n  });\n});","lineCount":102,"map":[[22,2,70,0,"Object"],[22,8,70,0],[22,9,70,0,"defineProperty"],[22,23,70,0],[22,24,70,0,"exports"],[22,31,70,0],[23,4,70,0,"enumerable"],[23,14,70,0],[24,4,70,0,"get"],[24,7,70,0],[24,18,70,0,"get"],[24,19,70,0],[25,6,70,0],[25,13,70,0,"tensorScatterUpdate"],[25,32,70,0],[26,4,70,0],[27,2,70,0],[28,2,17,0],[28,6,17,0,"_engine"],[28,13,17,0],[28,16,17,0,"require"],[28,23,17,0],[28,24,17,0,"_dependencyMap"],[28,38,17,0],[29,2,18,0],[29,6,18,0,"_kernel_names"],[29,19,18,0],[29,22,18,0,"require"],[29,29,18,0],[29,30,18,0,"_dependencyMap"],[29,44,18,0],[30,2,19,0],[30,6,19,0,"_tensor_util_env"],[30,22,19,0],[30,25,19,0,"require"],[30,32,19,0],[30,33,19,0,"_dependencyMap"],[30,47,19,0],[31,2,20,0],[31,6,20,0,"_operation"],[31,16,20,0],[31,19,20,0,"require"],[31,26,20,0],[31,27,20,0,"_dependencyMap"],[31,41,20,0],[32,2,21,0],[32,6,21,0,"_scatter_nd_util"],[32,22,21,0],[32,25,21,0,"require"],[32,32,21,0],[32,33,21,0,"_dependencyMap"],[32,47,21,0],[33,2,21,0],[33,6,21,0,"scatter_nd_util"],[33,21,21,0],[33,24,21,0,"_interopNamespace"],[33,41,21,0],[33,42,21,0,"_scatter_nd_util"],[33,58,21,0],[34,2,1,0],[35,0,2,0],[36,0,3,0],[37,0,4,0],[38,0,5,0],[39,0,6,0],[40,0,7,0],[41,0,8,0],[42,0,9,0],[43,0,10,0],[44,0,11,0],[45,0,12,0],[46,0,13,0],[47,0,14,0],[48,0,15,0],[49,0,16,0],[51,2,22,0],[52,0,23,0],[53,0,24,0],[54,0,25,0],[55,0,26,0],[56,0,27,0],[57,0,28,0],[58,0,29,0],[59,0,30,0],[60,0,31,0],[61,0,32,0],[62,0,33,0],[63,0,34,0],[64,0,35,0],[65,0,36,0],[66,0,37,0],[67,0,38,0],[68,0,39,0],[69,0,40,0],[70,0,41,0],[71,0,42,0],[72,0,43,0],[73,0,44,0],[74,0,45,0],[75,0,46,0],[76,0,47,0],[77,0,48,0],[78,0,49,0],[79,0,50,0],[80,0,51,0],[81,0,52,0],[82,2,53,0],[82,11,53,9,"tensorScatterUpdate_"],[82,31,53,29,"tensorScatterUpdate_"],[82,32,53,30,"tensor"],[82,38,53,36],[82,40,53,38,"indices"],[82,47,53,45],[82,49,53,47,"updates"],[82,56,53,54],[82,58,53,56],[83,4,54,4],[83,10,54,10,"$tensor"],[83,17,54,17],[83,20,54,20],[83,24,54,20,"convertToTensor"],[83,40,54,35],[83,41,54,35,"convertToTensor"],[83,56,54,35],[83,58,54,36,"tensor"],[83,64,54,42],[83,66,54,44],[83,74,54,52],[83,76,54,54],[83,97,54,75],[83,98,54,76],[84,4,55,4],[84,10,55,10,"$indices"],[84,18,55,18],[84,21,55,21],[84,25,55,21,"convertToTensor"],[84,41,55,36],[84,42,55,36,"convertToTensor"],[84,57,55,36],[84,59,55,37,"indices"],[84,66,55,44],[84,68,55,46],[84,77,55,55],[84,79,55,57],[84,100,55,78],[84,102,55,80],[84,109,55,87],[84,110,55,88],[85,4,56,4],[85,10,56,10,"$updates"],[85,18,56,18],[85,21,56,21],[85,25,56,21,"convertToTensor"],[85,41,56,36],[85,42,56,36,"convertToTensor"],[85,57,56,36],[85,59,56,37,"updates"],[85,66,56,44],[85,68,56,46],[85,77,56,55],[85,79,56,57],[85,100,56,78],[85,101,56,79],[86,4,57,4,"scatter_nd_util"],[86,19,57,19],[86,20,57,20,"validateInput"],[86,33,57,33],[86,34,57,34,"$updates"],[86,42,57,42],[86,44,57,44,"$indices"],[86,52,57,52],[86,54,57,54,"$tensor"],[86,61,57,61],[86,62,57,62,"shape"],[86,67,57,67],[86,68,57,68],[87,4,58,4],[87,8,58,8,"$tensor"],[87,15,58,15],[87,16,58,16,"dtype"],[87,21,58,21],[87,26,58,26,"$updates"],[87,34,58,34],[87,35,58,35,"dtype"],[87,40,58,40],[87,42,58,42],[88,6,59,8],[88,12,59,14],[88,16,59,18,"Error"],[88,21,59,23],[88,22,59,24],[88,87,59,89,"$tensor"],[88,94,59,96],[88,95,59,97,"dtype"],[88,100,59,102],[88,108,59,110,"$updates"],[88,116,59,118],[88,117,59,119,"dtype"],[88,122,59,124],[88,125,59,127],[88,126,59,128],[89,4,60,4],[90,4,61,4],[90,10,61,10,"inputs"],[90,16,61,16],[90,19,61,19],[91,6,62,8,"tensor"],[91,12,62,14],[91,14,62,16,"$tensor"],[91,21,62,23],[92,6,63,8,"indices"],[92,13,63,15],[92,15,63,17,"$indices"],[92,23,63,25],[93,6,64,8,"updates"],[93,13,64,15],[93,15,64,17,"$updates"],[94,4,65,4],[94,5,65,5],[95,4,66,4],[95,10,66,10,"attrs"],[95,15,66,15],[95,18,66,18],[95,19,66,19],[95,20,66,20],[96,4,67,4],[97,4,68,4],[97,11,68,11,"ENGINE"],[97,18,68,17],[97,19,68,17,"ENGINE"],[97,25,68,17],[97,26,68,18,"runKernel"],[97,35,68,27],[97,36,68,28,"TensorScatterUpdate"],[97,49,68,47],[97,50,68,47,"TensorScatterUpdate"],[97,69,68,47],[97,71,68,49,"inputs"],[97,77,68,55],[97,79,68,57,"attrs"],[97,84,68,62],[97,85,68,63],[98,2,69,0],[99,2,70,7],[99,8,70,13,"tensorScatterUpdate"],[99,27,70,32],[99,30,70,35],[99,34,70,35,"op"],[99,44,70,37],[99,45,70,37,"op"],[99,47,70,37],[99,49,70,38],[100,4,70,40,"tensorScatterUpdate_"],[101,2,70,61],[101,3,70,62],[101,4,70,63],[102,0,70,64],[102,3]],"functionMap":{"names":["<global>","tensorScatterUpdate_"],"mappings":"AAA;ACoD;CDgB"},"hasCjsExports":false},"type":"js/module"}]}