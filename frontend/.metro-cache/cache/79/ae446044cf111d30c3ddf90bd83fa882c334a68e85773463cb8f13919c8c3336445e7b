{"dependencies":[{"name":"@tensorflow/tfjs-core","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":22,"column":0,"index":868},"end":{"line":22,"column":45,"index":913}}],"key":"qIleUpSDMUXFynEGc51k60/pDSs=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  exports.assertShapesMatchAllowUndefinedSize = assertShapesMatchAllowUndefinedSize;\n  exports.fullDefinedShape = fullDefinedShape;\n  exports.inferElementShape = inferElementShape;\n  exports.mergeElementShape = mergeElementShape;\n  var _tensorflowTfjsCore = require(_dependencyMap[0], \"@tensorflow/tfjs-core\");\n  /**\n   * @license\n   * Copyright 2020 Google LLC. All Rights Reserved.\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   * =============================================================================\n   */\n  /**\n   * This differs from util.assertShapesMatch in that it allows values of\n   * negative one, an undefined size of a dimensinon, in a shape to match\n   * anything.\n   */\n\n  /**\n   * Used by TensorList and TensorArray to verify if elementShape matches, support\n   * negative value as the dim shape.\n   * @param shapeA\n   * @param shapeB\n   * @param errorMessagePrefix\n   */\n  function assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix = '') {\n    // constant shape means unknown rank\n    if (typeof shapeA === 'number' || typeof shapeB === 'number') {\n      return;\n    }\n    _tensorflowTfjsCore.util.assert(shapeA.length === shapeB.length, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);\n    for (let i = 0; i < shapeA.length; i++) {\n      const dim0 = shapeA[i];\n      const dim1 = shapeB[i];\n      _tensorflowTfjsCore.util.assert(dim0 < 0 || dim1 < 0 || dim0 === dim1, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);\n    }\n  }\n  function fullDefinedShape(elementShape) {\n    if (typeof elementShape === 'number' || elementShape.some(dim => dim < 0)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Generate the output element shape from the list elementShape, list tensors\n   * and input param.\n   * @param listElementShape\n   * @param tensors\n   * @param elementShape\n   */\n  function inferElementShape(listElementShape, tensors, elementShape) {\n    let partialShape = mergeElementShape(listElementShape, elementShape);\n    const notfullDefinedShape = !fullDefinedShape(partialShape);\n    if (notfullDefinedShape && tensors.length === 0) {\n      throw new Error(`Tried to calculate elements of an empty list` + ` with non-fully-defined elementShape: ${partialShape}`);\n    }\n    if (notfullDefinedShape) {\n      tensors.forEach(tensor => {\n        partialShape = mergeElementShape(tensor.shape, partialShape);\n      });\n    }\n    if (!fullDefinedShape(partialShape)) {\n      throw new Error(`Non-fully-defined elementShape: ${partialShape}`);\n    }\n    return partialShape;\n  }\n  function mergeElementShape(elementShapeA, elementShapeB) {\n    if (typeof elementShapeA === 'number') {\n      return elementShapeB;\n    }\n    if (typeof elementShapeB === 'number') {\n      return elementShapeA;\n    }\n    if (elementShapeA.length !== elementShapeB.length) {\n      throw new Error(`Incompatible ranks during merge: ${elementShapeA} vs. ${elementShapeB}`);\n    }\n    const result = [];\n    for (let i = 0; i < elementShapeA.length; ++i) {\n      const dim0 = elementShapeA[i];\n      const dim1 = elementShapeB[i];\n      if (dim0 >= 0 && dim1 >= 0 && dim0 !== dim1) {\n        throw new Error(`Incompatible shape during merge: ${elementShapeA} vs. ${elementShapeB}`);\n      }\n      result[i] = dim0 >= 0 ? dim0 : dim1;\n    }\n    return result;\n  }\n});","lineCount":103,"map":[[7,2,30,0,"exports"],[7,9,30,0],[7,10,30,0,"assertShapesMatchAllowUndefinedSize"],[7,45,30,0],[7,48,30,0,"assertShapesMatchAllowUndefinedSize"],[7,83,30,0],[8,2,42,0,"exports"],[8,9,42,0],[8,10,42,0,"fullDefinedShape"],[8,26,42,0],[8,29,42,0,"fullDefinedShape"],[8,45,42,0],[9,2,55,0,"exports"],[9,9,55,0],[9,10,55,0,"inferElementShape"],[9,27,55,0],[9,30,55,0,"inferElementShape"],[9,47,55,0],[10,2,72,0,"exports"],[10,9,72,0],[10,10,72,0,"mergeElementShape"],[10,27,72,0],[10,30,72,0,"mergeElementShape"],[10,47,72,0],[11,2,22,0],[11,6,22,0,"_tensorflowTfjsCore"],[11,25,22,0],[11,28,22,0,"require"],[11,35,22,0],[11,36,22,0,"_dependencyMap"],[11,50,22,0],[12,2,1,0],[13,0,2,0],[14,0,3,0],[15,0,4,0],[16,0,5,0],[17,0,6,0],[18,0,7,0],[19,0,8,0],[20,0,9,0],[21,0,10,0],[22,0,11,0],[23,0,12,0],[24,0,13,0],[25,0,14,0],[26,0,15,0],[27,0,16,0],[28,2,17,0],[29,0,18,0],[30,0,19,0],[31,0,20,0],[32,0,21,0],[34,2,23,0],[35,0,24,0],[36,0,25,0],[37,0,26,0],[38,0,27,0],[39,0,28,0],[40,0,29,0],[41,2,30,7],[41,11,30,16,"assertShapesMatchAllowUndefinedSize"],[41,46,30,51,"assertShapesMatchAllowUndefinedSize"],[41,47,30,52,"shapeA"],[41,53,30,58],[41,55,30,60,"shapeB"],[41,61,30,66],[41,63,30,68,"errorMessagePrefix"],[41,81,30,86],[41,84,30,89],[41,86,30,91],[41,88,30,93],[42,4,31,4],[43,4,32,4],[43,8,32,8],[43,15,32,15,"shapeA"],[43,21,32,21],[43,26,32,26],[43,34,32,34],[43,38,32,38],[43,45,32,45,"shapeB"],[43,51,32,51],[43,56,32,56],[43,64,32,64],[43,66,32,66],[44,6,33,8],[45,4,34,4],[46,4,35,4,"util"],[46,23,35,8],[46,24,35,8,"util"],[46,28,35,8],[46,29,35,9,"assert"],[46,35,35,15],[46,36,35,16,"shapeA"],[46,42,35,22],[46,43,35,23,"length"],[46,49,35,29],[46,54,35,34,"shapeB"],[46,60,35,40],[46,61,35,41,"length"],[46,67,35,47],[46,69,35,49],[46,75,35,55,"errorMessagePrefix"],[46,93,35,73],[46,96,35,76],[46,107,35,87,"shapeA"],[46,113,35,93],[46,121,35,101,"shapeB"],[46,127,35,107],[46,140,35,120],[46,141,35,121],[47,4,36,4],[47,9,36,9],[47,13,36,13,"i"],[47,14,36,14],[47,17,36,17],[47,18,36,18],[47,20,36,20,"i"],[47,21,36,21],[47,24,36,24,"shapeA"],[47,30,36,30],[47,31,36,31,"length"],[47,37,36,37],[47,39,36,39,"i"],[47,40,36,40],[47,42,36,42],[47,44,36,44],[48,6,37,8],[48,12,37,14,"dim0"],[48,16,37,18],[48,19,37,21,"shapeA"],[48,25,37,27],[48,26,37,28,"i"],[48,27,37,29],[48,28,37,30],[49,6,38,8],[49,12,38,14,"dim1"],[49,16,38,18],[49,19,38,21,"shapeB"],[49,25,38,27],[49,26,38,28,"i"],[49,27,38,29],[49,28,38,30],[50,6,39,8,"util"],[50,25,39,12],[50,26,39,12,"util"],[50,30,39,12],[50,31,39,13,"assert"],[50,37,39,19],[50,38,39,20,"dim0"],[50,42,39,24],[50,45,39,27],[50,46,39,28],[50,50,39,32,"dim1"],[50,54,39,36],[50,57,39,39],[50,58,39,40],[50,62,39,44,"dim0"],[50,66,39,48],[50,71,39,53,"dim1"],[50,75,39,57],[50,77,39,59],[50,83,39,65,"errorMessagePrefix"],[50,101,39,83],[50,104,39,86],[50,115,39,97,"shapeA"],[50,121,39,103],[50,129,39,111,"shapeB"],[50,135,39,117],[50,148,39,130],[50,149,39,131],[51,4,40,4],[52,2,41,0],[53,2,42,7],[53,11,42,16,"fullDefinedShape"],[53,27,42,32,"fullDefinedShape"],[53,28,42,33,"elementShape"],[53,40,42,45],[53,42,42,47],[54,4,43,4],[54,8,43,8],[54,15,43,15,"elementShape"],[54,27,43,27],[54,32,43,32],[54,40,43,40],[54,44,43,44,"elementShape"],[54,56,43,56],[54,57,43,57,"some"],[54,61,43,61],[54,62,43,62,"dim"],[54,65,43,65],[54,69,43,69,"dim"],[54,72,43,72],[54,75,43,75],[54,76,43,76],[54,77,43,77],[54,79,43,79],[55,6,44,8],[55,13,44,15],[55,18,44,20],[56,4,45,4],[57,4,46,4],[57,11,46,11],[57,15,46,15],[58,2,47,0],[59,2,48,0],[60,0,49,0],[61,0,50,0],[62,0,51,0],[63,0,52,0],[64,0,53,0],[65,0,54,0],[66,2,55,7],[66,11,55,16,"inferElementShape"],[66,28,55,33,"inferElementShape"],[66,29,55,34,"listElementShape"],[66,45,55,50],[66,47,55,52,"tensors"],[66,54,55,59],[66,56,55,61,"elementShape"],[66,68,55,73],[66,70,55,75],[67,4,56,4],[67,8,56,8,"partialShape"],[67,20,56,20],[67,23,56,23,"mergeElementShape"],[67,40,56,40],[67,41,56,41,"listElementShape"],[67,57,56,57],[67,59,56,59,"elementShape"],[67,71,56,71],[67,72,56,72],[68,4,57,4],[68,10,57,10,"notfullDefinedShape"],[68,29,57,29],[68,32,57,32],[68,33,57,33,"fullDefinedShape"],[68,49,57,49],[68,50,57,50,"partialShape"],[68,62,57,62],[68,63,57,63],[69,4,58,4],[69,8,58,8,"notfullDefinedShape"],[69,27,58,27],[69,31,58,31,"tensors"],[69,38,58,38],[69,39,58,39,"length"],[69,45,58,45],[69,50,58,50],[69,51,58,51],[69,53,58,53],[70,6,59,8],[70,12,59,14],[70,16,59,18,"Error"],[70,21,59,23],[70,22,59,24],[70,68,59,70],[70,71,60,12],[70,112,60,53,"partialShape"],[70,124,60,65],[70,126,60,67],[70,127,60,68],[71,4,61,4],[72,4,62,4],[72,8,62,8,"notfullDefinedShape"],[72,27,62,27],[72,29,62,29],[73,6,63,8,"tensors"],[73,13,63,15],[73,14,63,16,"forEach"],[73,21,63,23],[73,22,63,24,"tensor"],[73,28,63,30],[73,32,63,34],[74,8,64,12,"partialShape"],[74,20,64,24],[74,23,64,27,"mergeElementShape"],[74,40,64,44],[74,41,64,45,"tensor"],[74,47,64,51],[74,48,64,52,"shape"],[74,53,64,57],[74,55,64,59,"partialShape"],[74,67,64,71],[74,68,64,72],[75,6,65,8],[75,7,65,9],[75,8,65,10],[76,4,66,4],[77,4,67,4],[77,8,67,8],[77,9,67,9,"fullDefinedShape"],[77,25,67,25],[77,26,67,26,"partialShape"],[77,38,67,38],[77,39,67,39],[77,41,67,41],[78,6,68,8],[78,12,68,14],[78,16,68,18,"Error"],[78,21,68,23],[78,22,68,24],[78,57,68,59,"partialShape"],[78,69,68,71],[78,71,68,73],[78,72,68,74],[79,4,69,4],[80,4,70,4],[80,11,70,11,"partialShape"],[80,23,70,23],[81,2,71,0],[82,2,72,7],[82,11,72,16,"mergeElementShape"],[82,28,72,33,"mergeElementShape"],[82,29,72,34,"elementShapeA"],[82,42,72,47],[82,44,72,49,"elementShapeB"],[82,57,72,62],[82,59,72,64],[83,4,73,4],[83,8,73,8],[83,15,73,15,"elementShapeA"],[83,28,73,28],[83,33,73,33],[83,41,73,41],[83,43,73,43],[84,6,74,8],[84,13,74,15,"elementShapeB"],[84,26,74,28],[85,4,75,4],[86,4,76,4],[86,8,76,8],[86,15,76,15,"elementShapeB"],[86,28,76,28],[86,33,76,33],[86,41,76,41],[86,43,76,43],[87,6,77,8],[87,13,77,15,"elementShapeA"],[87,26,77,28],[88,4,78,4],[89,4,79,4],[89,8,79,8,"elementShapeA"],[89,21,79,21],[89,22,79,22,"length"],[89,28,79,28],[89,33,79,33,"elementShapeB"],[89,46,79,46],[89,47,79,47,"length"],[89,53,79,53],[89,55,79,55],[90,6,80,8],[90,12,80,14],[90,16,80,18,"Error"],[90,21,80,23],[90,22,80,24],[90,58,80,60,"elementShapeA"],[90,71,80,73],[90,79,80,81,"elementShapeB"],[90,92,80,94],[90,94,80,96],[90,95,80,97],[91,4,81,4],[92,4,82,4],[92,10,82,10,"result"],[92,16,82,16],[92,19,82,19],[92,21,82,21],[93,4,83,4],[93,9,83,9],[93,13,83,13,"i"],[93,14,83,14],[93,17,83,17],[93,18,83,18],[93,20,83,20,"i"],[93,21,83,21],[93,24,83,24,"elementShapeA"],[93,37,83,37],[93,38,83,38,"length"],[93,44,83,44],[93,46,83,46],[93,48,83,48,"i"],[93,49,83,49],[93,51,83,51],[94,6,84,8],[94,12,84,14,"dim0"],[94,16,84,18],[94,19,84,21,"elementShapeA"],[94,32,84,34],[94,33,84,35,"i"],[94,34,84,36],[94,35,84,37],[95,6,85,8],[95,12,85,14,"dim1"],[95,16,85,18],[95,19,85,21,"elementShapeB"],[95,32,85,34],[95,33,85,35,"i"],[95,34,85,36],[95,35,85,37],[96,6,86,8],[96,10,86,12,"dim0"],[96,14,86,16],[96,18,86,20],[96,19,86,21],[96,23,86,25,"dim1"],[96,27,86,29],[96,31,86,33],[96,32,86,34],[96,36,86,38,"dim0"],[96,40,86,42],[96,45,86,47,"dim1"],[96,49,86,51],[96,51,86,53],[97,8,87,12],[97,14,87,18],[97,18,87,22,"Error"],[97,23,87,27],[97,24,87,28],[97,60,87,64,"elementShapeA"],[97,73,87,77],[97,81,87,85,"elementShapeB"],[97,94,87,98],[97,96,87,100],[97,97,87,101],[98,6,88,8],[99,6,89,8,"result"],[99,12,89,14],[99,13,89,15,"i"],[99,14,89,16],[99,15,89,17],[99,18,89,20,"dim0"],[99,22,89,24],[99,26,89,28],[99,27,89,29],[99,30,89,32,"dim0"],[99,34,89,36],[99,37,89,39,"dim1"],[99,41,89,43],[100,4,90,4],[101,4,91,4],[101,11,91,11,"result"],[101,17,91,17],[102,2,92,0],[103,0,92,1],[103,3]],"functionMap":{"names":["<global>","assertShapesMatchAllowUndefinedSize","util.assert$argument_1","fullDefinedShape","elementShape.some$argument_0","inferElementShape","tensors.forEach$argument_0","mergeElementShape"],"mappings":"AAA;OC6B;iDCK,uED;2DCI,uED;CDE;OGC;8DCC,cD;CHI;OKQ;wBCQ;SDE;CLM;OOC;CPoB"},"hasCjsExports":false},"type":"js/module"}]}