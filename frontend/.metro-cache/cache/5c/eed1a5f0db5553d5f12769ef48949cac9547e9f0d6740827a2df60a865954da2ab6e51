{"dependencies":[],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"FFTProgram\", {\n    enumerable: true,\n    get: function () {\n      return FFTProgram;\n    }\n  });\n  /**\n   * @license\n   * Copyright 2018 Google LLC. All Rights Reserved.\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   * =============================================================================\n   */\n  class FFTProgram {\n    constructor(component, inputShape, inverse) {\n      this.variableNames = ['real', 'imag'];\n      const innerDim = inputShape[1];\n      this.outputShape = inputShape;\n      const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;\n      const resultDenominator = inverse ? `${innerDim}.0` : '1.0';\n      let opString;\n      if (component === 'real') {\n        opString = 'return real * expR - imag * expI;';\n      } else if (component === 'imag') {\n        opString = 'return real * expI + imag * expR;';\n      } else {\n        throw new Error(`FFT component must be either \"real\" or \"imag\", got ${component}.`);\n      }\n      this.userCode = `\n      const float exponentMultiplier = ${exponentMultiplierSnippet};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${opString}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${innerDim});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${innerDim}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `;\n    }\n  }\n});","lineCount":80,"map":[[7,2,17,0,"Object"],[7,8,17,0],[7,9,17,0,"defineProperty"],[7,23,17,0],[7,24,17,0,"exports"],[7,31,17,0],[8,4,17,0,"enumerable"],[8,14,17,0],[9,4,17,0,"get"],[9,7,17,0],[9,18,17,0,"get"],[9,19,17,0],[10,6,17,0],[10,13,17,0,"FFTProgram"],[10,23,17,0],[11,4,17,0],[12,2,17,0],[13,2,1,0],[14,0,2,0],[15,0,3,0],[16,0,4,0],[17,0,5,0],[18,0,6,0],[19,0,7,0],[20,0,8,0],[21,0,9,0],[22,0,10,0],[23,0,11,0],[24,0,12,0],[25,0,13,0],[26,0,14,0],[27,0,15,0],[28,0,16,0],[29,2,17,7],[29,8,17,13,"FFTProgram"],[29,18,17,23],[29,19,17,24],[30,4,18,4,"constructor"],[30,15,18,15,"constructor"],[30,16,18,16,"component"],[30,25,18,25],[30,27,18,27,"inputShape"],[30,37,18,37],[30,39,18,39,"inverse"],[30,46,18,46],[30,48,18,48],[31,6,19,8],[31,10,19,12],[31,11,19,13,"variableNames"],[31,24,19,26],[31,27,19,29],[31,28,19,30],[31,34,19,36],[31,36,19,38],[31,42,19,44],[31,43,19,45],[32,6,20,8],[32,12,20,14,"innerDim"],[32,20,20,22],[32,23,20,25,"inputShape"],[32,33,20,35],[32,34,20,36],[32,35,20,37],[32,36,20,38],[33,6,21,8],[33,10,21,12],[33,11,21,13,"outputShape"],[33,22,21,24],[33,25,21,27,"inputShape"],[33,35,21,37],[34,6,22,8],[34,12,22,14,"exponentMultiplierSnippet"],[34,37,22,39],[34,40,22,42,"inverse"],[34,47,22,49],[34,50,22,52],[34,59,22,61,"Math"],[34,63,22,65],[34,64,22,66,"PI"],[34,66,22,68],[34,68,22,70],[34,71,22,73],[34,81,22,83,"Math"],[34,85,22,87],[34,86,22,88,"PI"],[34,88,22,90],[34,90,22,92],[35,6,23,8],[35,12,23,14,"resultDenominator"],[35,29,23,31],[35,32,23,34,"inverse"],[35,39,23,41],[35,42,23,44],[35,45,23,47,"innerDim"],[35,53,23,55],[35,57,23,59],[35,60,23,62],[35,65,23,67],[36,6,24,8],[36,10,24,12,"opString"],[36,18,24,20],[37,6,25,8],[37,10,25,12,"component"],[37,19,25,21],[37,24,25,26],[37,30,25,32],[37,32,25,34],[38,8,26,12,"opString"],[38,16,26,20],[38,19,26,23],[38,54,26,58],[39,6,27,8],[39,7,27,9],[39,13,28,13],[39,17,28,17,"component"],[39,26,28,26],[39,31,28,31],[39,37,28,37],[39,39,28,39],[40,8,29,12,"opString"],[40,16,29,20],[40,19,29,23],[40,54,29,58],[41,6,30,8],[41,7,30,9],[41,13,31,13],[42,8,32,12],[42,14,32,18],[42,18,32,22,"Error"],[42,23,32,27],[42,24,32,28],[42,78,32,82,"component"],[42,87,32,91],[42,90,32,94],[42,91,32,95],[43,6,33,8],[44,6,34,8],[44,10,34,12],[44,11,34,13,"userCode"],[44,19,34,21],[44,22,34,24],[45,0,35,0],[45,41,35,41,"exponentMultiplierSnippet"],[45,66,35,66],[46,0,36,0],[47,0,37,0],[48,0,38,0],[48,10,38,10,"opString"],[48,18,38,18],[49,0,39,0],[50,0,40,0],[51,0,41,0],[52,0,42,0],[52,50,42,50,"innerDim"],[52,58,42,58],[53,0,43,0],[54,0,44,0],[55,0,45,0],[56,0,46,0],[57,0,47,0],[58,0,48,0],[58,30,48,30,"innerDim"],[58,38,48,38],[59,0,49,0],[60,0,50,0],[61,0,51,0],[62,0,52,0],[63,0,53,0],[64,0,54,0],[65,0,55,0],[66,0,56,0],[67,0,57,0],[67,57,57,57,"resultDenominator"],[67,74,57,74],[68,0,58,0],[69,0,59,0],[70,0,60,0],[71,0,61,0],[72,0,62,0],[73,0,63,0],[74,0,64,0],[75,0,65,0],[76,0,66,0],[77,0,67,0],[77,5,67,5],[78,4,68,4],[79,2,69,0],[80,0,69,1],[80,3]],"functionMap":{"names":["<global>","FFTProgram","FFTProgram#constructor"],"mappings":"AAA;OCgB;ICC;KDkD;CDC"},"hasCjsExports":false},"type":"js/module"}]}