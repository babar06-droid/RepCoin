{"dependencies":[{"name":"../engine","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":17,"column":0,"index":703},"end":{"line":17,"column":35,"index":738}}],"key":"zbTTi8rtwr8rjl75PzEo829Yvss=","exportNames":["*"],"imports":1}},{"name":"../kernel_names","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":18,"column":0,"index":739},"end":{"line":18,"column":55,"index":794}}],"key":"gQVznmdGA0uoBQvR5Q4/qW+ITHg=","exportNames":["*"],"imports":1}},{"name":"../tensor_util_env","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":19,"column":0,"index":795},"end":{"line":19,"column":53,"index":848}}],"key":"UCKDOr/oOGi3nbD26ZhyAVW61qk=","exportNames":["*"],"imports":1}},{"name":"./operation","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":20,"column":0,"index":849},"end":{"line":20,"column":33,"index":882}}],"key":"lmmEAb6oR3TWnrsrETceKUovfkM=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"raggedTensorToTensor\", {\n    enumerable: true,\n    get: function () {\n      return raggedTensorToTensor;\n    }\n  });\n  var _engine = require(_dependencyMap[0], \"../engine\");\n  var _kernel_names = require(_dependencyMap[1], \"../kernel_names\");\n  var _tensor_util_env = require(_dependencyMap[2], \"../tensor_util_env\");\n  var _operation = require(_dependencyMap[3], \"./operation\");\n  /**\n   * @license\n   * Copyright 2022 Google LLC. All Rights Reserved.\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   * =============================================================================\n   */\n\n  /**\n   * Create a dense tensor from a ragged tensor, possibly altering its shape.\n   *\n   * The raggedTensorToTensor op creates a dense tensor from am array of row\n   * partition tensors, a value vector, and default values. If the shape is\n   * unspecified, the minimal shape required to contain all the elements in the\n   * ragged tensor (the natural shape) will be used. If some dimensions are left\n   * unspecified, then the size of the natural shape is used in that dimension.\n   *\n   * The defaultValue will be broadcast to the output shape. After that, the\n   * values from the ragged tensor overwrite the default values. Note that the\n   * defaultValue must have less dimensions than the value.\n   *\n   * The row partition tensors are in the order of the dimensions. At present, the\n   * types can be: \"ROW_SPLITS\": the row_splits tensor from the ragged tensor.\n   *   \"VALUE_ROWIDS\": the value_rowids tensor from the ragged tensor.\n   *   \"FIRST_DIM_SIZE\": if value_rowids is used for the first dimension, then it\n   * is preceded by \"FIRST_DIM_SIZE\".\n   * ```\n   * @param shape: A Tensor. Must be one of the following types: 'int32'. The\n   *     desired shape of the output tensor. If left unspecified (empty), the\n   *     minimal shape required to contain all the elements in the ragged tensor\n   *     (the natural shape) will be used. If some dimensions are left\n   *     unspecified, then the size of the natural shape is used in that\n   *     dimension.\n   *\n   *     Note that dense dimensions cannot be modified by the shape argument.\n   *     Trying to change the size of a dense dimension will cause the op to fail.\n   *     Examples: natural shape: [4, 5, 6] shape: -1 output shape: [4, 5, 6]\n   *\n   *     natural shape: [4, 5, 6] shape: [3, -1, 2] output shape: [3, 5, 2]\n   *\n   *     natural shape: [4, 5, 6] shape: [3, 7, 2] output shape: [3, 7, 2]\n   * @param values: A Tensor. A 1D tensor representing the values of the ragged\n   *     tensor.\n   * @param defaultValue: A Tensor. Must have the same type as values. The\n   *     defaultValue when the shape is larger than the ragged tensor. The\n   *     defaultValue is broadcast until it is the shape of the output tensor,\n   *     and then overwritten by values in the ragged tensor. The default value\n   *     must be compatible with this broadcast operation, and must have fewer\n   *     dimensions than the value tensor.\n   * @param rowPartitionTensors: A list of at least 1 Tensor objects with the same\n   *     type in: 'int32'.\n   * @param rowPartitionTypes: A list of strings. The types of the row partition\n   *     tensors. At present, these can be:\n   *     \"ROW_SPLITS\": the row_splits tensor from the ragged tensor.\n   *     \"VALUE_ROWIDS\": the value_rowids tensor from the ragged tensor.\n   *     \"FIRST_DIM_SIZE\": if value_rowids is used for the first dimension, then\n   *         it is preceded by \"FIRST_DIM_SIZE\". The tensors are in the order of\n   *         the dimensions.\n   * @return A Tensor. Has the same type as values.\n   * @doc {heading: 'Operations', subheading: 'Ragged'}\n   */\n  function raggedTensorToTensor_(shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes) {\n    const $shape = (0, _tensor_util_env.convertToTensor)(shape, 'shape', 'raggedTensorToTensor', 'int32');\n    const $values = (0, _tensor_util_env.convertToTensor)(values, 'values', 'raggedTensorToTensor');\n    const $defaultValue = (0, _tensor_util_env.convertToTensor)(defaultValue, 'defaultValue', 'raggedTensorToTensor', $values.dtype);\n    const $rowPartitionTensors = rowPartitionTensors.map((t, i) => (0, _tensor_util_env.convertToTensor)(t, `tensors${i}`, 'raggedTensorToTensor', 'int32'));\n    const inputs = {\n      shape: $shape,\n      values: $values,\n      defaultValue: $defaultValue,\n      rowPartitionTensors: $rowPartitionTensors\n    };\n    const attrs = {\n      rowPartitionTypes\n    };\n    return _engine.ENGINE.runKernel(_kernel_names.RaggedTensorToTensor, inputs, attrs);\n  }\n  const raggedTensorToTensor = /* @__PURE__ */(0, _operation.op)({\n    raggedTensorToTensor_\n  });\n});","lineCount":106,"map":[[7,2,88,0,"Object"],[7,8,88,0],[7,9,88,0,"defineProperty"],[7,23,88,0],[7,24,88,0,"exports"],[7,31,88,0],[8,4,88,0,"enumerable"],[8,14,88,0],[9,4,88,0,"get"],[9,7,88,0],[9,18,88,0,"get"],[9,19,88,0],[10,6,88,0],[10,13,88,0,"raggedTensorToTensor"],[10,33,88,0],[11,4,88,0],[12,2,88,0],[13,2,17,0],[13,6,17,0,"_engine"],[13,13,17,0],[13,16,17,0,"require"],[13,23,17,0],[13,24,17,0,"_dependencyMap"],[13,38,17,0],[14,2,18,0],[14,6,18,0,"_kernel_names"],[14,19,18,0],[14,22,18,0,"require"],[14,29,18,0],[14,30,18,0,"_dependencyMap"],[14,44,18,0],[15,2,19,0],[15,6,19,0,"_tensor_util_env"],[15,22,19,0],[15,25,19,0,"require"],[15,32,19,0],[15,33,19,0,"_dependencyMap"],[15,47,19,0],[16,2,20,0],[16,6,20,0,"_operation"],[16,16,20,0],[16,19,20,0,"require"],[16,26,20,0],[16,27,20,0,"_dependencyMap"],[16,41,20,0],[17,2,1,0],[18,0,2,0],[19,0,3,0],[20,0,4,0],[21,0,5,0],[22,0,6,0],[23,0,7,0],[24,0,8,0],[25,0,9,0],[26,0,10,0],[27,0,11,0],[28,0,12,0],[29,0,13,0],[30,0,14,0],[31,0,15,0],[32,0,16,0],[34,2,21,0],[35,0,22,0],[36,0,23,0],[37,0,24,0],[38,0,25,0],[39,0,26,0],[40,0,27,0],[41,0,28,0],[42,0,29,0],[43,0,30,0],[44,0,31,0],[45,0,32,0],[46,0,33,0],[47,0,34,0],[48,0,35,0],[49,0,36,0],[50,0,37,0],[51,0,38,0],[52,0,39,0],[53,0,40,0],[54,0,41,0],[55,0,42,0],[56,0,43,0],[57,0,44,0],[58,0,45,0],[59,0,46,0],[60,0,47,0],[61,0,48,0],[62,0,49,0],[63,0,50,0],[64,0,51,0],[65,0,52,0],[66,0,53,0],[67,0,54,0],[68,0,55,0],[69,0,56,0],[70,0,57,0],[71,0,58,0],[72,0,59,0],[73,0,60,0],[74,0,61,0],[75,0,62,0],[76,0,63,0],[77,0,64,0],[78,0,65,0],[79,0,66,0],[80,0,67,0],[81,0,68,0],[82,0,69,0],[83,0,70,0],[84,0,71,0],[85,0,72,0],[86,0,73,0],[87,2,74,0],[87,11,74,9,"raggedTensorToTensor_"],[87,32,74,30,"raggedTensorToTensor_"],[87,33,74,31,"shape"],[87,38,74,36],[87,40,74,38,"values"],[87,46,74,44],[87,48,74,46,"defaultValue"],[87,60,74,58],[87,62,74,60,"rowPartitionTensors"],[87,81,74,79],[87,83,74,81,"rowPartitionTypes"],[87,100,74,98],[87,102,74,100],[88,4,75,4],[88,10,75,10,"$shape"],[88,16,75,16],[88,19,75,19],[88,23,75,19,"convertToTensor"],[88,39,75,34],[88,40,75,34,"convertToTensor"],[88,55,75,34],[88,57,75,35,"shape"],[88,62,75,40],[88,64,75,42],[88,71,75,49],[88,73,75,51],[88,95,75,73],[88,97,75,75],[88,104,75,82],[88,105,75,83],[89,4,76,4],[89,10,76,10,"$values"],[89,17,76,17],[89,20,76,20],[89,24,76,20,"convertToTensor"],[89,40,76,35],[89,41,76,35,"convertToTensor"],[89,56,76,35],[89,58,76,36,"values"],[89,64,76,42],[89,66,76,44],[89,74,76,52],[89,76,76,54],[89,98,76,76],[89,99,76,77],[90,4,77,4],[90,10,77,10,"$defaultValue"],[90,23,77,23],[90,26,77,26],[90,30,77,26,"convertToTensor"],[90,46,77,41],[90,47,77,41,"convertToTensor"],[90,62,77,41],[90,64,77,42,"defaultValue"],[90,76,77,54],[90,78,77,56],[90,92,77,70],[90,94,77,72],[90,116,77,94],[90,118,77,96,"$values"],[90,125,77,103],[90,126,77,104,"dtype"],[90,131,77,109],[90,132,77,110],[91,4,78,4],[91,10,78,10,"$rowPartitionTensors"],[91,30,78,30],[91,33,78,33,"rowPartitionTensors"],[91,52,78,52],[91,53,78,53,"map"],[91,56,78,56],[91,57,78,57],[91,58,78,58,"t"],[91,59,78,59],[91,61,78,61,"i"],[91,62,78,62],[91,67,78,67],[91,71,78,67,"convertToTensor"],[91,87,78,82],[91,88,78,82,"convertToTensor"],[91,103,78,82],[91,105,78,83,"t"],[91,106,78,84],[91,108,78,86],[91,118,78,96,"i"],[91,119,78,97],[91,121,78,99],[91,123,78,101],[91,145,78,123],[91,147,78,125],[91,154,78,132],[91,155,78,133],[91,156,78,134],[92,4,79,4],[92,10,79,10,"inputs"],[92,16,79,16],[92,19,79,19],[93,6,80,8,"shape"],[93,11,80,13],[93,13,80,15,"$shape"],[93,19,80,21],[94,6,81,8,"values"],[94,12,81,14],[94,14,81,16,"$values"],[94,21,81,23],[95,6,82,8,"defaultValue"],[95,18,82,20],[95,20,82,22,"$defaultValue"],[95,33,82,35],[96,6,83,8,"rowPartitionTensors"],[96,25,83,27],[96,27,83,29,"$rowPartitionTensors"],[97,4,84,4],[97,5,84,5],[98,4,85,4],[98,10,85,10,"attrs"],[98,15,85,15],[98,18,85,18],[99,6,85,20,"rowPartitionTypes"],[100,4,85,38],[100,5,85,39],[101,4,86,4],[101,11,86,11,"ENGINE"],[101,18,86,17],[101,19,86,17,"ENGINE"],[101,25,86,17],[101,26,86,18,"runKernel"],[101,35,86,27],[101,36,86,28,"RaggedTensorToTensor"],[101,49,86,48],[101,50,86,48,"RaggedTensorToTensor"],[101,70,86,48],[101,72,86,50,"inputs"],[101,78,86,56],[101,80,86,58,"attrs"],[101,85,86,63],[101,86,86,64],[102,2,87,0],[103,2,88,7],[103,8,88,13,"raggedTensorToTensor"],[103,28,88,33],[103,31,88,36],[103,46,88,52],[103,50,88,52,"op"],[103,60,88,54],[103,61,88,54,"op"],[103,63,88,54],[103,65,88,55],[104,4,88,57,"raggedTensorToTensor_"],[105,2,88,79],[105,3,88,80],[105,4,88,81],[106,0,88,82],[106,3]],"functionMap":{"names":["<global>","raggedTensorToTensor_","rowPartitionTensors.map$argument_0"],"mappings":"AAA;ACyE;yDCI,4ED;CDS"},"hasCjsExports":false},"type":"js/module"}]}