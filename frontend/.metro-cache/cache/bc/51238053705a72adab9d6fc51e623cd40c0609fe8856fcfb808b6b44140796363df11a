{"dependencies":[{"name":"@tensorflow/tfjs-core","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":18,"column":0,"index":706},"end":{"line":18,"column":44,"index":750}}],"key":"qIleUpSDMUXFynEGc51k60/pDSs=","exportNames":["*"],"imports":1}},{"name":"string_decoder","data":{"asyncType":null,"isESMImport":false,"locs":[{"start":{"line":215,"column":34,"index":8719},"end":{"line":215,"column":59,"index":8744}}],"key":"Czn9Pd3w4g4vQh6KJoZw1JzHmic=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = {};\n    if (e) Object.keys(e).forEach(function (k) {\n      var d = Object.getOwnPropertyDescriptor(e, k);\n      Object.defineProperty(n, k, d.get ? d : {\n        enumerable: true,\n        get: function () {\n          return e[k];\n        }\n      });\n    });\n    n.default = e;\n    return n;\n  }\n  exports.deepMap = deepMap;\n  exports.deepZip = deepZip;\n  exports.zipToList = zipToList;\n  exports.deepMapAndAwaitAll = deepMapAndAwaitAll;\n  exports.isIterable = isIterable;\n  exports.canTensorify = canTensorify;\n  var _tensorflowTfjsCore = require(_dependencyMap[0], \"@tensorflow/tfjs-core\");\n  var tf = _interopNamespace(_tensorflowTfjsCore);\n  /**\n   * @license\n   * Copyright 2018 Google LLC. All Rights Reserved.\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * =============================================================================\n   */\n\n  /**\n   * Apply a mapping function to a nested structure in a recursive manner.\n   *\n   * The result of the mapping is an object with the same nested structure (i.e.,\n   * of arrays and dicts) as the input, except that some subtrees are replaced,\n   * according to the results of the mapping function.\n   *\n   * Mappings are memoized.  Thus, if the nested structure contains the same\n   * object in multiple positions, the output will contain the same mapped object\n   * in those positions.  Cycles are not supported, however.\n   *\n   * @param input: The object to which to apply the mapping function.\n   * @param mapFn: A function that expects a single node of the object tree, and\n   *   returns a `DeepMapResult`.  The `DeepMapResult` either provides a\n   *   replacement value for that node (i.e., replacing the subtree), or indicates\n   *   that the node should be processed recursively.\n   */\n  function deepMap(input, mapFn) {\n    return deepMapInternal(input, mapFn);\n  }\n  /**\n   * @param seen: A Map of known object mappings (i.e., memoized results of\n   *   `mapFn()`)\n   * @param containedIn: An set containing objects on the reference path currently\n   *   being processed (used to detect cycles).\n   */\n  function deepMapInternal(input, mapFn, seen = new Map(), containedIn = new Set()) {\n    if (input == null) {\n      return null;\n    }\n    if (typeof Blob === 'function' && input instanceof Blob) {\n      return input.slice();\n    }\n    if (containedIn.has(input)) {\n      throw new Error('Circular references are not supported.');\n    }\n    if (seen.has(input)) {\n      return seen.get(input);\n    }\n    const result = mapFn(input);\n    if (result.recurse && result.value !== null) {\n      throw new Error('A deep map function may not return both a value and recurse=true.');\n    }\n    if (!result.recurse) {\n      seen.set(input, result.value);\n      return result.value;\n    } else if (isIterable(input)) {\n      // tslint:disable-next-line:no-any\n      const mappedIterable = Array.isArray(input) ? [] : {};\n      containedIn.add(input);\n      for (const k in input) {\n        const child = input[k];\n        const childResult = deepMapInternal(child, mapFn, seen, containedIn);\n        mappedIterable[k] = childResult;\n      }\n      containedIn.delete(input);\n      if (input.__proto__) {\n        mappedIterable.__proto__ = input.__proto__;\n      }\n      return mappedIterable;\n    } else {\n      throw new Error(`Can't recurse into non-iterable type: ${input}`);\n    }\n  }\n  // TODO(soergel, kangyizhang) Reconsider naming of deepZip() to avoid confusion\n  // with zip()\n  /**\n   * Zip nested structures together in a recursive manner.\n   *\n   * This has the effect of transposing or pivoting data, e.g. converting it from\n   * a row-major representation to a column-major representation.\n   *\n   * For example, `deepZip([{a: 1, b: 2}, {a: 3, b: 4}])` returns\n   * `{a: [1, 3], b: [2, 4]}`.\n   *\n   * The inputs should all have the same nested structure (i.e., of arrays and\n   * dicts).  The result is a single object with the same nested structure, where\n   * the leaves are arrays collecting the values of the inputs at that location\n   * (or, optionally, the result of a custom function applied to those arrays).\n   *\n   * @param inputs: An array of the objects to zip together.\n   * @param zipFn: (optional) A function that expects an array of elements at a\n   *   single node of the object tree, and returns a `DeepMapResult`.  The\n   *   `DeepMapResult` either provides a result value for that node (i.e.,\n   *   representing the subtree), or indicates that the node should be processed\n   *   recursively.  The default zipFn recurses as far as possible and places\n   *   arrays at the leaves.\n   */\n  function deepZip(inputs, zipFn = zipToList) {\n    return deepZipInternal(inputs, zipFn);\n  }\n  /**\n   * @param containedIn: An set containing objects on the reference path currently\n   *   being processed (used to detect cycles).\n   */\n  function deepZipInternal(inputs, zipFn, containedIn = new Set()) {\n    // The recursion follows the structure of input 0; it's assumed that all the\n    // other inputs have the same structure.\n    const input = inputs[0];\n    if (containedIn.has(input)) {\n      throw new Error('Circular references are not supported.');\n    }\n    const result = zipFn(inputs);\n    if (result.recurse && result.value !== null) {\n      throw new Error('A deep zip function may not return both a value and recurse=true.');\n    }\n    if (!result.recurse) {\n      return result.value;\n    } else if (isIterable(input)) {\n      // tslint:disable-next-line:no-any\n      const mappedIterable = Array.isArray(input) ? [] : {};\n      containedIn.add(input);\n      for (const k in input) {\n        const children = inputs.map(x => x[k]);\n        const childResult = deepZipInternal(children, zipFn, containedIn);\n        mappedIterable[k] = childResult;\n      }\n      containedIn.delete(input);\n      return mappedIterable;\n    } else {\n      throw new Error(`Can't recurse into non-iterable type: ${input}`);\n    }\n  }\n  // tslint:disable-next-line:no-any\n  function zipToList(x) {\n    if (x === null) {\n      return null;\n    }\n    // TODO(soergel): validate array type?\n    if (isIterable(x[0])) {\n      return {\n        value: null,\n        recurse: true\n      };\n    } else {\n      return {\n        value: x,\n        recurse: false\n      };\n    }\n  }\n  /**\n   * Apply an async mapping function to a nested structure in a recursive manner.\n   *\n   * This first creates a nested structure of Promises, and then awaits all of\n   * those, resulting in a single Promise for a resolved nested structure.\n   *\n   * The result of the mapping is an object with the same nested structure (i.e.,\n   * of arrays and dicts) as the input, except that some subtrees are replaced,\n   * according to the results of the mapping function.\n   *\n   * Mappings are memoized.  Thus, if the nested structure contains the same\n   * object in multiple positions, the output will contain the same mapped object\n   * in those positions.  Cycles are not supported, however.\n   *\n   * @param input: The object to which to apply the mapping function.\n   * @param mapFn: A function that expects a single node of the object tree, and\n   *   returns a `DeepMapAsyncResult`.  The `DeepMapAsyncResult` either provides\n   *   a `Promise` for a replacement value for that node (i.e., replacing the\n   *   subtree), or indicates that the node should be processed recursively.  Note\n   *   that the decision whether or not to recurse must be made immediately; only\n   *   the mapped value may be promised.\n   */\n  async function deepMapAndAwaitAll(input, mapFn) {\n    const seen = new Map();\n    // First do a normal deepMap, collecting Promises in 'seen' as a side effect.\n    deepMapInternal(input, mapFn, seen);\n    // Replace the Promises in 'seen' in place.\n    // Note TypeScript provides no async map iteration, and regular map iteration\n    // is broken too, so sadly we have to do Array.from() to make it work.\n    // (There's no advantage to Promise.all(), and that would be tricky anyway.)\n    for (const key of Array.from(seen.keys())) {\n      const value = seen.get(key);\n      if (tf.util.isPromise(value)) {\n        const mappedValue = await value;\n        seen.set(key, mappedValue);\n      }\n    }\n    // Normal deepMap again, this time filling in the resolved values.\n    // It's unfortunate that we have to do two passes.\n    // TODO(soergel): test performance and think harder about a fast solution.\n    const result = deepMapInternal(input, mapFn, seen);\n    return result;\n  }\n  /**\n   * Determine whether the argument is iterable.\n   *\n   * @returns true if the argument is an array or any non-Tensor object.\n   */\n  // tslint:disable-next-line:no-any\n  function isIterable(obj) {\n    let isTextDecoder = false;\n    if (tf.env().get('IS_BROWSER')) {\n      isTextDecoder = obj instanceof TextDecoder;\n    } else {\n      // tslint:disable-next-line:no-require-imports\n      const {\n        StringDecoder\n      } = require(_dependencyMap[1], \"string_decoder\");\n      isTextDecoder = obj instanceof StringDecoder;\n    }\n    return obj != null && !ArrayBuffer.isView(obj) && (Array.isArray(obj) || typeof obj === 'object' && !(obj instanceof tf.Tensor) && !(obj instanceof Promise) && !isTextDecoder);\n  }\n  /**\n   * Determine whether the argument can be converted to Tensor.\n   *\n   * Tensors, primitives, arrays, and TypedArrays all qualify; anything else does\n   * not.\n   *\n   * @returns true if the argument can be converted to Tensor.\n   */\n  // tslint:disable-next-line:no-any\n  function canTensorify(obj) {\n    return obj == null || isPrimitive(obj) || Array.isArray(obj) || typeof obj === 'object' && obj instanceof tf.Tensor || tf.util.isTypedArray(obj);\n  }\n  /**\n   * Returns true if the given `value` is a primitive type. Otherwise returns\n   * false. This is equivalant to node util.isPrimitive\n   */\n  function isPrimitive(value) {\n    return value === null || typeof value !== 'object' && typeof value !== 'function';\n  }\n});","lineCount":270,"map":[[22,2,36,0,"exports"],[22,9,36,0],[22,10,36,0,"deepMap"],[22,17,36,0],[22,20,36,0,"deepMap"],[22,27,36,0],[23,2,109,0,"exports"],[23,9,109,0],[23,10,109,0,"deepZip"],[23,17,109,0],[23,20,109,0,"deepZip"],[23,27,109,0],[24,2,147,0,"exports"],[24,9,147,0],[24,10,147,0,"zipToList"],[24,19,147,0],[24,22,147,0,"zipToList"],[24,31,147,0],[25,2,181,0,"exports"],[25,9,181,0],[25,10,181,0,"deepMapAndAwaitAll"],[25,28,181,0],[25,31,181,0,"deepMapAndAwaitAll"],[25,49,181,0],[26,2,208,0,"exports"],[26,9,208,0],[26,10,208,0,"isIterable"],[26,20,208,0],[26,23,208,0,"isIterable"],[26,33,208,0],[27,2,232,0,"exports"],[27,9,232,0],[27,10,232,0,"canTensorify"],[27,22,232,0],[27,25,232,0,"canTensorify"],[27,37,232,0],[28,2,18,0],[28,6,18,0,"_tensorflowTfjsCore"],[28,25,18,0],[28,28,18,0,"require"],[28,35,18,0],[28,36,18,0,"_dependencyMap"],[28,50,18,0],[29,2,18,0],[29,6,18,0,"tf"],[29,8,18,0],[29,11,18,0,"_interopNamespace"],[29,28,18,0],[29,29,18,0,"_tensorflowTfjsCore"],[29,48,18,0],[30,2,1,0],[31,0,2,0],[32,0,3,0],[33,0,4,0],[34,0,5,0],[35,0,6,0],[36,0,7,0],[37,0,8,0],[38,0,9,0],[39,0,10,0],[40,0,11,0],[41,0,12,0],[42,0,13,0],[43,0,14,0],[44,0,15,0],[45,0,16,0],[46,0,17,0],[48,2,19,0],[49,0,20,0],[50,0,21,0],[51,0,22,0],[52,0,23,0],[53,0,24,0],[54,0,25,0],[55,0,26,0],[56,0,27,0],[57,0,28,0],[58,0,29,0],[59,0,30,0],[60,0,31,0],[61,0,32,0],[62,0,33,0],[63,0,34,0],[64,0,35,0],[65,2,36,7],[65,11,36,16,"deepMap"],[65,18,36,23,"deepMap"],[65,19,36,24,"input"],[65,24,36,29],[65,26,36,31,"mapFn"],[65,31,36,36],[65,33,36,38],[66,4,37,4],[66,11,37,11,"deepMapInternal"],[66,26,37,26],[66,27,37,27,"input"],[66,32,37,32],[66,34,37,34,"mapFn"],[66,39,37,39],[66,40,37,40],[67,2,38,0],[68,2,39,0],[69,0,40,0],[70,0,41,0],[71,0,42,0],[72,0,43,0],[73,0,44,0],[74,2,45,0],[74,11,45,9,"deepMapInternal"],[74,26,45,24,"deepMapInternal"],[74,27,45,25,"input"],[74,32,45,30],[74,34,45,32,"mapFn"],[74,39,45,37],[74,41,45,39,"seen"],[74,45,45,43],[74,48,45,46],[74,52,45,50,"Map"],[74,55,45,53],[74,56,45,54],[74,57,45,55],[74,59,45,57,"containedIn"],[74,70,45,68],[74,73,45,71],[74,77,45,75,"Set"],[74,80,45,78],[74,81,45,79],[74,82,45,80],[74,84,45,82],[75,4,46,4],[75,8,46,8,"input"],[75,13,46,13],[75,17,46,17],[75,21,46,21],[75,23,46,23],[76,6,47,8],[76,13,47,15],[76,17,47,19],[77,4,48,4],[78,4,49,4],[78,8,49,8],[78,15,49,15,"Blob"],[78,19,49,19],[78,24,49,24],[78,34,49,34],[78,38,49,38,"input"],[78,43,49,43],[78,55,49,55,"Blob"],[78,59,49,59],[78,61,49,61],[79,6,50,8],[79,13,50,15,"input"],[79,18,50,20],[79,19,50,21,"slice"],[79,24,50,26],[79,25,50,27],[79,26,50,28],[80,4,51,4],[81,4,52,4],[81,8,52,8,"containedIn"],[81,19,52,19],[81,20,52,20,"has"],[81,23,52,23],[81,24,52,24,"input"],[81,29,52,29],[81,30,52,30],[81,32,52,32],[82,6,53,8],[82,12,53,14],[82,16,53,18,"Error"],[82,21,53,23],[82,22,53,24],[82,62,53,64],[82,63,53,65],[83,4,54,4],[84,4,55,4],[84,8,55,8,"seen"],[84,12,55,12],[84,13,55,13,"has"],[84,16,55,16],[84,17,55,17,"input"],[84,22,55,22],[84,23,55,23],[84,25,55,25],[85,6,56,8],[85,13,56,15,"seen"],[85,17,56,19],[85,18,56,20,"get"],[85,21,56,23],[85,22,56,24,"input"],[85,27,56,29],[85,28,56,30],[86,4,57,4],[87,4,58,4],[87,10,58,10,"result"],[87,16,58,16],[87,19,58,19,"mapFn"],[87,24,58,24],[87,25,58,25,"input"],[87,30,58,30],[87,31,58,31],[88,4,59,4],[88,8,59,8,"result"],[88,14,59,14],[88,15,59,15,"recurse"],[88,22,59,22],[88,26,59,26,"result"],[88,32,59,32],[88,33,59,33,"value"],[88,38,59,38],[88,43,59,43],[88,47,59,47],[88,49,59,49],[89,6,60,8],[89,12,60,14],[89,16,60,18,"Error"],[89,21,60,23],[89,22,60,24],[89,89,60,91],[89,90,60,92],[90,4,61,4],[91,4,62,4],[91,8,62,8],[91,9,62,9,"result"],[91,15,62,15],[91,16,62,16,"recurse"],[91,23,62,23],[91,25,62,25],[92,6,63,8,"seen"],[92,10,63,12],[92,11,63,13,"set"],[92,14,63,16],[92,15,63,17,"input"],[92,20,63,22],[92,22,63,24,"result"],[92,28,63,30],[92,29,63,31,"value"],[92,34,63,36],[92,35,63,37],[93,6,64,8],[93,13,64,15,"result"],[93,19,64,21],[93,20,64,22,"value"],[93,25,64,27],[94,4,65,4],[94,5,65,5],[94,11,66,9],[94,15,66,13,"isIterable"],[94,25,66,23],[94,26,66,24,"input"],[94,31,66,29],[94,32,66,30],[94,34,66,32],[95,6,67,8],[96,6,68,8],[96,12,68,14,"mappedIterable"],[96,26,68,28],[96,29,68,31,"Array"],[96,34,68,36],[96,35,68,37,"isArray"],[96,42,68,44],[96,43,68,45,"input"],[96,48,68,50],[96,49,68,51],[96,52,68,54],[96,54,68,56],[96,57,68,59],[96,58,68,60],[96,59,68,61],[97,6,69,8,"containedIn"],[97,17,69,19],[97,18,69,20,"add"],[97,21,69,23],[97,22,69,24,"input"],[97,27,69,29],[97,28,69,30],[98,6,70,8],[98,11,70,13],[98,17,70,19,"k"],[98,18,70,20],[98,22,70,24,"input"],[98,27,70,29],[98,29,70,31],[99,8,71,12],[99,14,71,18,"child"],[99,19,71,23],[99,22,71,26,"input"],[99,27,71,31],[99,28,71,32,"k"],[99,29,71,33],[99,30,71,34],[100,8,72,12],[100,14,72,18,"childResult"],[100,25,72,29],[100,28,72,32,"deepMapInternal"],[100,43,72,47],[100,44,72,48,"child"],[100,49,72,53],[100,51,72,55,"mapFn"],[100,56,72,60],[100,58,72,62,"seen"],[100,62,72,66],[100,64,72,68,"containedIn"],[100,75,72,79],[100,76,72,80],[101,8,73,12,"mappedIterable"],[101,22,73,26],[101,23,73,27,"k"],[101,24,73,28],[101,25,73,29],[101,28,73,32,"childResult"],[101,39,73,43],[102,6,74,8],[103,6,75,8,"containedIn"],[103,17,75,19],[103,18,75,20,"delete"],[103,24,75,26],[103,25,75,27,"input"],[103,30,75,32],[103,31,75,33],[104,6,76,8],[104,10,76,12,"input"],[104,15,76,17],[104,16,76,18,"__proto__"],[104,25,76,27],[104,27,76,29],[105,8,77,12,"mappedIterable"],[105,22,77,26],[105,23,77,27,"__proto__"],[105,32,77,36],[105,35,77,39,"input"],[105,40,77,44],[105,41,77,45,"__proto__"],[105,50,77,54],[106,6,78,8],[107,6,79,8],[107,13,79,15,"mappedIterable"],[107,27,79,29],[108,4,80,4],[108,5,80,5],[108,11,81,9],[109,6,82,8],[109,12,82,14],[109,16,82,18,"Error"],[109,21,82,23],[109,22,82,24],[109,63,82,65,"input"],[109,68,82,70],[109,70,82,72],[109,71,82,73],[110,4,83,4],[111,2,84,0],[112,2,85,0],[113,2,86,0],[114,2,87,0],[115,0,88,0],[116,0,89,0],[117,0,90,0],[118,0,91,0],[119,0,92,0],[120,0,93,0],[121,0,94,0],[122,0,95,0],[123,0,96,0],[124,0,97,0],[125,0,98,0],[126,0,99,0],[127,0,100,0],[128,0,101,0],[129,0,102,0],[130,0,103,0],[131,0,104,0],[132,0,105,0],[133,0,106,0],[134,0,107,0],[135,0,108,0],[136,2,109,7],[136,11,109,16,"deepZip"],[136,18,109,23,"deepZip"],[136,19,109,24,"inputs"],[136,25,109,30],[136,27,109,32,"zipFn"],[136,32,109,37],[136,35,109,40,"zipToList"],[136,44,109,49],[136,46,109,51],[137,4,110,4],[137,11,110,11,"deepZipInternal"],[137,26,110,26],[137,27,110,27,"inputs"],[137,33,110,33],[137,35,110,35,"zipFn"],[137,40,110,40],[137,41,110,41],[138,2,111,0],[139,2,112,0],[140,0,113,0],[141,0,114,0],[142,0,115,0],[143,2,116,0],[143,11,116,9,"deepZipInternal"],[143,26,116,24,"deepZipInternal"],[143,27,116,25,"inputs"],[143,33,116,31],[143,35,116,33,"zipFn"],[143,40,116,38],[143,42,116,40,"containedIn"],[143,53,116,51],[143,56,116,54],[143,60,116,58,"Set"],[143,63,116,61],[143,64,116,62],[143,65,116,63],[143,67,116,65],[144,4,117,4],[145,4,118,4],[146,4,119,4],[146,10,119,10,"input"],[146,15,119,15],[146,18,119,18,"inputs"],[146,24,119,24],[146,25,119,25],[146,26,119,26],[146,27,119,27],[147,4,120,4],[147,8,120,8,"containedIn"],[147,19,120,19],[147,20,120,20,"has"],[147,23,120,23],[147,24,120,24,"input"],[147,29,120,29],[147,30,120,30],[147,32,120,32],[148,6,121,8],[148,12,121,14],[148,16,121,18,"Error"],[148,21,121,23],[148,22,121,24],[148,62,121,64],[148,63,121,65],[149,4,122,4],[150,4,123,4],[150,10,123,10,"result"],[150,16,123,16],[150,19,123,19,"zipFn"],[150,24,123,24],[150,25,123,25,"inputs"],[150,31,123,31],[150,32,123,32],[151,4,124,4],[151,8,124,8,"result"],[151,14,124,14],[151,15,124,15,"recurse"],[151,22,124,22],[151,26,124,26,"result"],[151,32,124,32],[151,33,124,33,"value"],[151,38,124,38],[151,43,124,43],[151,47,124,47],[151,49,124,49],[152,6,125,8],[152,12,125,14],[152,16,125,18,"Error"],[152,21,125,23],[152,22,125,24],[152,89,125,91],[152,90,125,92],[153,4,126,4],[154,4,127,4],[154,8,127,8],[154,9,127,9,"result"],[154,15,127,15],[154,16,127,16,"recurse"],[154,23,127,23],[154,25,127,25],[155,6,128,8],[155,13,128,15,"result"],[155,19,128,21],[155,20,128,22,"value"],[155,25,128,27],[156,4,129,4],[156,5,129,5],[156,11,130,9],[156,15,130,13,"isIterable"],[156,25,130,23],[156,26,130,24,"input"],[156,31,130,29],[156,32,130,30],[156,34,130,32],[157,6,131,8],[158,6,132,8],[158,12,132,14,"mappedIterable"],[158,26,132,28],[158,29,132,31,"Array"],[158,34,132,36],[158,35,132,37,"isArray"],[158,42,132,44],[158,43,132,45,"input"],[158,48,132,50],[158,49,132,51],[158,52,132,54],[158,54,132,56],[158,57,132,59],[158,58,132,60],[158,59,132,61],[159,6,133,8,"containedIn"],[159,17,133,19],[159,18,133,20,"add"],[159,21,133,23],[159,22,133,24,"input"],[159,27,133,29],[159,28,133,30],[160,6,134,8],[160,11,134,13],[160,17,134,19,"k"],[160,18,134,20],[160,22,134,24,"input"],[160,27,134,29],[160,29,134,31],[161,8,135,12],[161,14,135,18,"children"],[161,22,135,26],[161,25,135,29,"inputs"],[161,31,135,35],[161,32,135,36,"map"],[161,35,135,39],[161,36,135,40,"x"],[161,37,135,41],[161,41,135,45,"x"],[161,42,135,46],[161,43,135,47,"k"],[161,44,135,48],[161,45,135,49],[161,46,135,50],[162,8,136,12],[162,14,136,18,"childResult"],[162,25,136,29],[162,28,136,32,"deepZipInternal"],[162,43,136,47],[162,44,136,48,"children"],[162,52,136,56],[162,54,136,58,"zipFn"],[162,59,136,63],[162,61,136,65,"containedIn"],[162,72,136,76],[162,73,136,77],[163,8,137,12,"mappedIterable"],[163,22,137,26],[163,23,137,27,"k"],[163,24,137,28],[163,25,137,29],[163,28,137,32,"childResult"],[163,39,137,43],[164,6,138,8],[165,6,139,8,"containedIn"],[165,17,139,19],[165,18,139,20,"delete"],[165,24,139,26],[165,25,139,27,"input"],[165,30,139,32],[165,31,139,33],[166,6,140,8],[166,13,140,15,"mappedIterable"],[166,27,140,29],[167,4,141,4],[167,5,141,5],[167,11,142,9],[168,6,143,8],[168,12,143,14],[168,16,143,18,"Error"],[168,21,143,23],[168,22,143,24],[168,63,143,65,"input"],[168,68,143,70],[168,70,143,72],[168,71,143,73],[169,4,144,4],[170,2,145,0],[171,2,146,0],[172,2,147,7],[172,11,147,16,"zipToList"],[172,20,147,25,"zipToList"],[172,21,147,26,"x"],[172,22,147,27],[172,24,147,29],[173,4,148,4],[173,8,148,8,"x"],[173,9,148,9],[173,14,148,14],[173,18,148,18],[173,20,148,20],[174,6,149,8],[174,13,149,15],[174,17,149,19],[175,4,150,4],[176,4,151,4],[177,4,152,4],[177,8,152,8,"isIterable"],[177,18,152,18],[177,19,152,19,"x"],[177,20,152,20],[177,21,152,21],[177,22,152,22],[177,23,152,23],[177,24,152,24],[177,26,152,26],[178,6,153,8],[178,13,153,15],[179,8,153,17,"value"],[179,13,153,22],[179,15,153,24],[179,19,153,28],[180,8,153,30,"recurse"],[180,15,153,37],[180,17,153,39],[181,6,153,44],[181,7,153,45],[182,4,154,4],[182,5,154,5],[182,11,155,9],[183,6,156,8],[183,13,156,15],[184,8,156,17,"value"],[184,13,156,22],[184,15,156,24,"x"],[184,16,156,25],[185,8,156,27,"recurse"],[185,15,156,34],[185,17,156,36],[186,6,156,42],[186,7,156,43],[187,4,157,4],[188,2,158,0],[189,2,159,0],[190,0,160,0],[191,0,161,0],[192,0,162,0],[193,0,163,0],[194,0,164,0],[195,0,165,0],[196,0,166,0],[197,0,167,0],[198,0,168,0],[199,0,169,0],[200,0,170,0],[201,0,171,0],[202,0,172,0],[203,0,173,0],[204,0,174,0],[205,0,175,0],[206,0,176,0],[207,0,177,0],[208,0,178,0],[209,0,179,0],[210,0,180,0],[211,2,181,7],[211,17,181,22,"deepMapAndAwaitAll"],[211,35,181,40,"deepMapAndAwaitAll"],[211,36,181,41,"input"],[211,41,181,46],[211,43,181,48,"mapFn"],[211,48,181,53],[211,50,181,55],[212,4,182,4],[212,10,182,10,"seen"],[212,14,182,14],[212,17,182,17],[212,21,182,21,"Map"],[212,24,182,24],[212,25,182,25],[212,26,182,26],[213,4,183,4],[214,4,184,4,"deepMapInternal"],[214,19,184,19],[214,20,184,20,"input"],[214,25,184,25],[214,27,184,27,"mapFn"],[214,32,184,32],[214,34,184,34,"seen"],[214,38,184,38],[214,39,184,39],[215,4,185,4],[216,4,186,4],[217,4,187,4],[218,4,188,4],[219,4,189,4],[219,9,189,9],[219,15,189,15,"key"],[219,18,189,18],[219,22,189,22,"Array"],[219,27,189,27],[219,28,189,28,"from"],[219,32,189,32],[219,33,189,33,"seen"],[219,37,189,37],[219,38,189,38,"keys"],[219,42,189,42],[219,43,189,43],[219,44,189,44],[219,45,189,45],[219,47,189,47],[220,6,190,8],[220,12,190,14,"value"],[220,17,190,19],[220,20,190,22,"seen"],[220,24,190,26],[220,25,190,27,"get"],[220,28,190,30],[220,29,190,31,"key"],[220,32,190,34],[220,33,190,35],[221,6,191,8],[221,10,191,12,"tf"],[221,12,191,14],[221,13,191,15,"util"],[221,17,191,19],[221,18,191,20,"isPromise"],[221,27,191,29],[221,28,191,30,"value"],[221,33,191,35],[221,34,191,36],[221,36,191,38],[222,8,192,12],[222,14,192,18,"mappedValue"],[222,25,192,29],[222,28,192,32],[222,34,192,38,"value"],[222,39,192,43],[223,8,193,12,"seen"],[223,12,193,16],[223,13,193,17,"set"],[223,16,193,20],[223,17,193,21,"key"],[223,20,193,24],[223,22,193,26,"mappedValue"],[223,33,193,37],[223,34,193,38],[224,6,194,8],[225,4,195,4],[226,4,196,4],[227,4,197,4],[228,4,198,4],[229,4,199,4],[229,10,199,10,"result"],[229,16,199,16],[229,19,199,19,"deepMapInternal"],[229,34,199,34],[229,35,199,35,"input"],[229,40,199,40],[229,42,199,42,"mapFn"],[229,47,199,47],[229,49,199,49,"seen"],[229,53,199,53],[229,54,199,54],[230,4,200,4],[230,11,200,11,"result"],[230,17,200,17],[231,2,201,0],[232,2,202,0],[233,0,203,0],[234,0,204,0],[235,0,205,0],[236,0,206,0],[237,2,207,0],[238,2,208,7],[238,11,208,16,"isIterable"],[238,21,208,26,"isIterable"],[238,22,208,27,"obj"],[238,25,208,30],[238,27,208,32],[239,4,209,4],[239,8,209,8,"isTextDecoder"],[239,21,209,21],[239,24,209,24],[239,29,209,29],[240,4,210,4],[240,8,210,8,"tf"],[240,10,210,10],[240,11,210,11,"env"],[240,14,210,14],[240,15,210,15],[240,16,210,16],[240,17,210,17,"get"],[240,20,210,20],[240,21,210,21],[240,33,210,33],[240,34,210,34],[240,36,210,36],[241,6,211,8,"isTextDecoder"],[241,19,211,21],[241,22,211,24,"obj"],[241,25,211,27],[241,37,211,39,"TextDecoder"],[241,48,211,50],[242,4,212,4],[242,5,212,5],[242,11,213,9],[243,6,214,8],[244,6,215,8],[244,12,215,14],[245,8,215,16,"StringDecoder"],[246,6,215,30],[246,7,215,31],[246,10,215,34,"require"],[246,17,215,41],[246,18,215,41,"_dependencyMap"],[246,32,215,41],[246,53,215,58],[246,54,215,59],[247,6,216,8,"isTextDecoder"],[247,19,216,21],[247,22,216,24,"obj"],[247,25,216,27],[247,37,216,39,"StringDecoder"],[247,50,216,52],[248,4,217,4],[249,4,218,4],[249,11,218,11,"obj"],[249,14,218,14],[249,18,218,18],[249,22,218,22],[249,26,218,27],[249,27,218,28,"ArrayBuffer"],[249,38,218,39],[249,39,218,40,"isView"],[249,45,218,46],[249,46,218,47,"obj"],[249,49,218,50],[249,50,218,52],[249,55,219,9,"Array"],[249,60,219,14],[249,61,219,15,"isArray"],[249,68,219,22],[249,69,219,23,"obj"],[249,72,219,26],[249,73,219,27],[249,77,220,13],[249,84,220,20,"obj"],[249,87,220,23],[249,92,220,28],[249,100,220,36],[249,104,220,40],[249,106,220,42,"obj"],[249,109,220,45],[249,121,220,57,"tf"],[249,123,220,59],[249,124,220,60,"Tensor"],[249,130,220,66],[249,131,220,67],[249,135,221,16],[249,137,221,18,"obj"],[249,140,221,21],[249,152,221,33,"Promise"],[249,159,221,40],[249,160,221,41],[249,164,221,45],[249,165,221,46,"isTextDecoder"],[249,178,221,60],[249,179,221,61],[250,2,222,0],[251,2,223,0],[252,0,224,0],[253,0,225,0],[254,0,226,0],[255,0,227,0],[256,0,228,0],[257,0,229,0],[258,0,230,0],[259,2,231,0],[260,2,232,7],[260,11,232,16,"canTensorify"],[260,23,232,28,"canTensorify"],[260,24,232,29,"obj"],[260,27,232,32],[260,29,232,34],[261,4,233,4],[261,11,233,11,"obj"],[261,14,233,14],[261,18,233,18],[261,22,233,22],[261,26,233,26,"isPrimitive"],[261,37,233,37],[261,38,233,38,"obj"],[261,41,233,41],[261,42,233,42],[261,46,233,46,"Array"],[261,51,233,51],[261,52,233,52,"isArray"],[261,59,233,59],[261,60,233,60,"obj"],[261,63,233,63],[261,64,233,64],[261,68,234,9],[261,75,234,16,"obj"],[261,78,234,19],[261,83,234,24],[261,91,234,32],[261,95,234,37,"obj"],[261,98,234,40],[261,110,234,52,"tf"],[261,112,234,54],[261,113,234,55,"Tensor"],[261,119,234,63],[261,123,235,8,"tf"],[261,125,235,10],[261,126,235,11,"util"],[261,130,235,15],[261,131,235,16,"isTypedArray"],[261,143,235,28],[261,144,235,29,"obj"],[261,147,235,32],[261,148,235,33],[262,2,236,0],[263,2,237,0],[264,0,238,0],[265,0,239,0],[266,0,240,0],[267,2,241,0],[267,11,241,9,"isPrimitive"],[267,22,241,20,"isPrimitive"],[267,23,241,21,"value"],[267,28,241,26],[267,30,241,28],[268,4,242,4],[268,11,242,12,"value"],[268,16,242,17],[268,21,242,22],[268,25,242,26],[268,29,243,9],[268,36,243,16,"value"],[268,41,243,21],[268,46,243,26],[268,54,243,34],[268,58,243,38],[268,65,243,45,"value"],[268,70,243,50],[268,75,243,55],[268,85,243,66],[269,2,244,0],[270,0,244,1],[270,3]],"functionMap":{"names":["<global>","deepMap","deepMapInternal","deepZip","deepZipInternal","inputs.map$argument_0","zipToList","deepMapAndAwaitAll","isIterable","canTensorify","isPrimitive"],"mappings":"AAA;OCmC;CDE;AEO;CFuC;OGyB;CHE;AIK;wCCmB,SD;CJU;OME;CNW;OOuB;CPoB;OQO;CRc;OSU;CTI;AUK;CVG"},"hasCjsExports":false},"type":"js/module"}]}