{"dependencies":[],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"SwapProgram\", {\n    enumerable: true,\n    get: function () {\n      return SwapProgram;\n    }\n  });\n  Object.defineProperty(exports, \"MergeProgram\", {\n    enumerable: true,\n    get: function () {\n      return MergeProgram;\n    }\n  });\n  // Based on Algorithm 2 of Bitonic Top K, ref:\n  // https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\n  // The original algorithm is based on computing the top K only, however\n  // since for TFJS we require the indices of the top K values as well then the\n  // algorithm found here is a bit modified. Rather than producing the values\n  // at each step, the indices containing the top K are generated instead.\n  // The output values are not generated to reduce the number of outputs in the\n  // GPU, the values can easily be retrieved from the indices using a gather\n  // op.\n  class SwapProgram {\n    /**\n     * @param shape desired output shape (can be larger than input shape, output\n     *                                    will be padded with -Infinity)\n     */\n    constructor(shape) {\n      this.variableNames = ['x', 'indices'];\n      // |n| Size of the original input of TopK.\n      // |firstPass|indicates if this is the first time swap is being used which\n      // means no indices input containing the top K is present yet.\n      // |inc| Swaps pairs of indices (0, inc), (1, inc + 1), (2, inc + 2) ...\n      this.customUniforms = [{\n        name: 'n',\n        type: 'int'\n      }, {\n        name: 'firstPass',\n        type: 'int'\n      }, {\n        name: 'negativeInf',\n        type: 'float'\n      }, {\n        name: 'dir',\n        type: 'int'\n      }, {\n        name: 'inc',\n        type: 'int'\n      }];\n      this.outputShape = shape;\n      this.userCode = `\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     `;\n    }\n  }\n  class MergeProgram {\n    /**\n     * @param shape desired output shape (must be half of the input size)\n     */\n    constructor(shape) {\n      this.variableNames = ['x', 'indices'];\n      // |n| Size of the original input of TopK\n      // |firstPass| indicates if this is the first time swap is being used which\n      // means no indices input containing the top K is present yet.\n      // |k| Top k elements desired\n      this.customUniforms = [{\n        name: 'n',\n        type: 'int'\n      }, {\n        name: 'firstPass',\n        type: 'int'\n      }, {\n        name: 'k',\n        type: 'int'\n      }];\n      this.outputShape = shape;\n      this.userCode = `\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     `;\n    }\n  }\n});","lineCount":157,"map":[[7,2,10,0,"Object"],[7,8,10,0],[7,9,10,0,"defineProperty"],[7,23,10,0],[7,24,10,0,"exports"],[7,31,10,0],[8,4,10,0,"enumerable"],[8,14,10,0],[9,4,10,0,"get"],[9,7,10,0],[9,18,10,0,"get"],[9,19,10,0],[10,6,10,0],[10,13,10,0,"SwapProgram"],[10,24,10,0],[11,4,10,0],[12,2,10,0],[13,2,72,0,"Object"],[13,8,72,0],[13,9,72,0,"defineProperty"],[13,23,72,0],[13,24,72,0,"exports"],[13,31,72,0],[14,4,72,0,"enumerable"],[14,14,72,0],[15,4,72,0,"get"],[15,7,72,0],[15,18,72,0,"get"],[15,19,72,0],[16,6,72,0],[16,13,72,0,"MergeProgram"],[16,25,72,0],[17,4,72,0],[18,2,72,0],[19,2,1,0],[20,2,2,0],[21,2,3,0],[22,2,4,0],[23,2,5,0],[24,2,6,0],[25,2,7,0],[26,2,8,0],[27,2,9,0],[28,2,10,7],[28,8,10,13,"SwapProgram"],[28,19,10,24],[28,20,10,25],[29,4,11,4],[30,0,12,0],[31,0,13,0],[32,0,14,0],[33,4,15,4,"constructor"],[33,15,15,15,"constructor"],[33,16,15,16,"shape"],[33,21,15,21],[33,23,15,23],[34,6,16,8],[34,10,16,12],[34,11,16,13,"variableNames"],[34,24,16,26],[34,27,16,29],[34,28,16,30],[34,31,16,33],[34,33,16,35],[34,42,16,44],[34,43,16,45],[35,6,17,8],[36,6,18,8],[37,6,19,8],[38,6,20,8],[39,6,21,8],[39,10,21,12],[39,11,21,13,"customUniforms"],[39,25,21,27],[39,28,21,30],[39,29,22,12],[40,8,22,14,"name"],[40,12,22,18],[40,14,22,20],[40,17,22,23],[41,8,22,25,"type"],[41,12,22,29],[41,14,22,31],[42,6,22,37],[42,7,22,38],[42,9,23,12],[43,8,23,14,"name"],[43,12,23,18],[43,14,23,20],[43,25,23,31],[44,8,23,33,"type"],[44,12,23,37],[44,14,23,39],[45,6,23,45],[45,7,23,46],[45,9,24,12],[46,8,24,14,"name"],[46,12,24,18],[46,14,24,20],[46,27,24,33],[47,8,24,35,"type"],[47,12,24,39],[47,14,24,41],[48,6,24,49],[48,7,24,50],[48,9,25,12],[49,8,25,14,"name"],[49,12,25,18],[49,14,25,20],[49,19,25,25],[50,8,25,27,"type"],[50,12,25,31],[50,14,25,33],[51,6,25,39],[51,7,25,40],[51,9,26,12],[52,8,26,14,"name"],[52,12,26,18],[52,14,26,20],[52,19,26,25],[53,8,26,27,"type"],[53,12,26,31],[53,14,26,33],[54,6,26,39],[54,7,26,40],[54,8,27,9],[55,6,28,8],[55,10,28,12],[55,11,28,13,"outputShape"],[55,22,28,24],[55,25,28,27,"shape"],[55,30,28,32],[56,6,29,8],[56,10,29,12],[56,11,29,13,"userCode"],[56,19,29,21],[56,22,29,24],[57,0,30,0],[58,0,31,0],[59,0,32,0],[60,0,33,0],[61,0,34,0],[62,0,35,0],[63,0,36,0],[64,0,37,0],[65,0,38,0],[66,0,39,0],[67,0,40,0],[68,0,41,0],[69,0,42,0],[70,0,43,0],[71,0,44,0],[72,0,45,0],[73,0,46,0],[74,0,47,0],[75,0,48,0],[76,0,49,0],[77,0,50,0],[78,0,51,0],[79,0,52,0],[80,0,53,0],[81,0,54,0],[82,0,55,0],[83,0,56,0],[84,0,57,0],[85,0,58,0],[86,0,59,0],[87,0,60,0],[88,0,61,0],[89,0,62,0],[90,0,63,0],[91,0,64,0],[92,0,65,0],[93,0,66,0],[94,0,67,0],[95,0,68,0],[96,0,69,0],[96,6,69,6],[97,4,70,4],[98,2,71,0],[99,2,72,7],[99,8,72,13,"MergeProgram"],[99,20,72,25],[99,21,72,26],[100,4,73,4],[101,0,74,0],[102,0,75,0],[103,4,76,4,"constructor"],[103,15,76,15,"constructor"],[103,16,76,16,"shape"],[103,21,76,21],[103,23,76,23],[104,6,77,8],[104,10,77,12],[104,11,77,13,"variableNames"],[104,24,77,26],[104,27,77,29],[104,28,77,30],[104,31,77,33],[104,33,77,35],[104,42,77,44],[104,43,77,45],[105,6,78,8],[106,6,79,8],[107,6,80,8],[108,6,81,8],[109,6,82,8],[109,10,82,12],[109,11,82,13,"customUniforms"],[109,25,82,27],[109,28,82,30],[109,29,83,12],[110,8,83,14,"name"],[110,12,83,18],[110,14,83,20],[110,17,83,23],[111,8,83,25,"type"],[111,12,83,29],[111,14,83,31],[112,6,83,37],[112,7,83,38],[112,9,84,12],[113,8,84,14,"name"],[113,12,84,18],[113,14,84,20],[113,25,84,31],[114,8,84,33,"type"],[114,12,84,37],[114,14,84,39],[115,6,84,45],[115,7,84,46],[115,9,85,12],[116,8,85,14,"name"],[116,12,85,18],[116,14,85,20],[116,17,85,23],[117,8,85,25,"type"],[117,12,85,29],[117,14,85,31],[118,6,85,37],[118,7,85,38],[118,8,86,9],[119,6,87,8],[119,10,87,12],[119,11,87,13,"outputShape"],[119,22,87,24],[119,25,87,27,"shape"],[119,30,87,32],[120,6,88,8],[120,10,88,12],[120,11,88,13,"userCode"],[120,19,88,21],[120,22,88,24],[121,0,89,0],[122,0,90,0],[123,0,91,0],[124,0,92,0],[125,0,93,0],[126,0,94,0],[127,0,95,0],[128,0,96,0],[129,0,97,0],[130,0,98,0],[131,0,99,0],[132,0,100,0],[133,0,101,0],[134,0,102,0],[135,0,103,0],[136,0,104,0],[137,0,105,0],[138,0,106,0],[139,0,107,0],[140,0,108,0],[141,0,109,0],[142,0,110,0],[143,0,111,0],[144,0,112,0],[145,0,113,0],[146,0,114,0],[147,0,115,0],[148,0,116,0],[149,0,117,0],[150,0,118,0],[151,0,119,0],[152,0,120,0],[153,0,121,0],[154,0,122,0],[154,6,122,6],[155,4,123,4],[156,2,124,0],[157,0,124,1],[157,3]],"functionMap":{"names":["<global>","SwapProgram","SwapProgram#constructor","MergeProgram","MergeProgram#constructor"],"mappings":"AAA;OCS;ICK;KDuD;CDC;OGC;ICI;KD+C;CHC"},"hasCjsExports":false},"type":"js/module"}]}