{"dependencies":[{"name":"../../engine","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":17,"column":0,"index":703},"end":{"line":17,"column":38,"index":741}}],"key":"v39fFCcPTN6kCKPiVEOA5hKbvfQ=","exportNames":["*"],"imports":1}},{"name":"../../kernel_names","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":18,"column":0,"index":742},"end":{"line":18,"column":55,"index":797}}],"key":"rL3QmnnDJzxi3tNgrJ9K3IiMDQ8=","exportNames":["*"],"imports":1}},{"name":"../../tensor_util_env","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":19,"column":0,"index":798},"end":{"line":19,"column":56,"index":854}}],"key":"xfSGNGkCJdZhfQ673y/6d+no2yU=","exportNames":["*"],"imports":1}},{"name":"../operation","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":20,"column":0,"index":855},"end":{"line":20,"column":34,"index":889}}],"key":"fQilPqfSvhAHjyfKT0P4wel7jE4=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"sparseSegmentMean\", {\n    enumerable: true,\n    get: function () {\n      return sparseSegmentMean;\n    }\n  });\n  var _engine = require(_dependencyMap[0], \"../../engine\");\n  var _kernel_names = require(_dependencyMap[1], \"../../kernel_names\");\n  var _tensor_util_env = require(_dependencyMap[2], \"../../tensor_util_env\");\n  var _operation = require(_dependencyMap[3], \"../operation\");\n  /**\n   * @license\n   * Copyright 2021 Google LLC. All Rights Reserved.\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   * =============================================================================\n   */\n\n  /**\n   * Computes the mean along sparse segments of a tensor.\n   *\n   * ```js\n   * const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [6,7,8,9]]);\n   * // Select two rows, one segment.\n   * const result1 = tf.sparse.sparseSegmentMean(c,\n   *                                           tf.tensor1d([0, 1], 'int32'),\n   *                                           tf.tensor1d([0, 0], 'int32'));\n   * result1.print(); // [[0, 0, 0, 0]]\n   *\n   * // Select two rows, two segments.\n   * const result2 = tf.sparse.sparseSegmentMean(c,\n   *                                             tf.tensor1d([0, 1], 'int32'),\n   *                                             tf.tensor1d([0, 1], 'int32'));\n   * result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]\n   *\n   * // Select all rows, two segments.\n   * const result3 = tf.sparse.sparseSegmentMean(c,\n   *                                             tf.tensor1d([0, 1, 2], 'int32'),\n   *                                             tf.tensor1d([0, 1, 1], 'int32'));\n   * result3.print(); // [[1.0, 2.0, 3.0, 4.0], [2.5, 2.5, 2.5, 2.5]]\n   * ```\n   * @param data: A Tensor of at least one dimension with data that will be\n   *     assembled in the output.\n   * @param indices: A 1-D Tensor with indices into data. Has same rank as\n   *     segmentIds.\n   * @param segmentIds: A 1-D Tensor with indices into the output Tensor. Values\n   *     should be sorted and can be repeated.\n   * @return Has same shape as data, except for dimension 0 which has equal to\n   *         the number of segments.\n   *\n   * @doc {heading: 'Operations', subheading: 'Sparse'}\n   */\n  function sparseSegmentMean_(data, indices, segmentIds) {\n    const $data = (0, _tensor_util_env.convertToTensor)(data, 'data', 'sparseSegmentMean');\n    const $indices = (0, _tensor_util_env.convertToTensor)(indices, 'indices', 'sparseSegmentMean', 'int32');\n    const $segmentIds = (0, _tensor_util_env.convertToTensor)(segmentIds, 'segmentIds', 'sparseSegmentMean', 'int32');\n    if ($data.rank < 1) {\n      throw new Error(`Data should be at least 1 dimensional but received scalar`);\n    }\n    if ($indices.rank !== 1) {\n      throw new Error(`Indices should be Tensor1D but received shape\n          ${$indices.shape}`);\n    }\n    if ($segmentIds.rank !== 1) {\n      throw new Error(`Segment ids should be Tensor1D but received shape\n          ${$segmentIds.shape}`);\n    }\n    const inputs = {\n      data: $data,\n      indices: $indices,\n      segmentIds: $segmentIds\n    };\n    return _engine.ENGINE.runKernel(_kernel_names.SparseSegmentMean, inputs);\n  }\n  const sparseSegmentMean = /* @__PURE__ */(0, _operation.op)({\n    sparseSegmentMean_\n  });\n});","lineCount":93,"map":[[7,2,77,0,"Object"],[7,8,77,0],[7,9,77,0,"defineProperty"],[7,23,77,0],[7,24,77,0,"exports"],[7,31,77,0],[8,4,77,0,"enumerable"],[8,14,77,0],[9,4,77,0,"get"],[9,7,77,0],[9,18,77,0,"get"],[9,19,77,0],[10,6,77,0],[10,13,77,0,"sparseSegmentMean"],[10,30,77,0],[11,4,77,0],[12,2,77,0],[13,2,17,0],[13,6,17,0,"_engine"],[13,13,17,0],[13,16,17,0,"require"],[13,23,17,0],[13,24,17,0,"_dependencyMap"],[13,38,17,0],[14,2,18,0],[14,6,18,0,"_kernel_names"],[14,19,18,0],[14,22,18,0,"require"],[14,29,18,0],[14,30,18,0,"_dependencyMap"],[14,44,18,0],[15,2,19,0],[15,6,19,0,"_tensor_util_env"],[15,22,19,0],[15,25,19,0,"require"],[15,32,19,0],[15,33,19,0,"_dependencyMap"],[15,47,19,0],[16,2,20,0],[16,6,20,0,"_operation"],[16,16,20,0],[16,19,20,0,"require"],[16,26,20,0],[16,27,20,0,"_dependencyMap"],[16,41,20,0],[17,2,1,0],[18,0,2,0],[19,0,3,0],[20,0,4,0],[21,0,5,0],[22,0,6,0],[23,0,7,0],[24,0,8,0],[25,0,9,0],[26,0,10,0],[27,0,11,0],[28,0,12,0],[29,0,13,0],[30,0,14,0],[31,0,15,0],[32,0,16,0],[34,2,21,0],[35,0,22,0],[36,0,23,0],[37,0,24,0],[38,0,25,0],[39,0,26,0],[40,0,27,0],[41,0,28,0],[42,0,29,0],[43,0,30,0],[44,0,31,0],[45,0,32,0],[46,0,33,0],[47,0,34,0],[48,0,35,0],[49,0,36,0],[50,0,37,0],[51,0,38,0],[52,0,39,0],[53,0,40,0],[54,0,41,0],[55,0,42,0],[56,0,43,0],[57,0,44,0],[58,0,45,0],[59,0,46,0],[60,0,47,0],[61,0,48,0],[62,0,49,0],[63,0,50,0],[64,0,51,0],[65,0,52,0],[66,0,53,0],[67,0,54,0],[68,2,55,0],[68,11,55,9,"sparseSegmentMean_"],[68,29,55,27,"sparseSegmentMean_"],[68,30,55,28,"data"],[68,34,55,32],[68,36,55,34,"indices"],[68,43,55,41],[68,45,55,43,"segmentIds"],[68,55,55,53],[68,57,55,55],[69,4,56,4],[69,10,56,10,"$data"],[69,15,56,15],[69,18,56,18],[69,22,56,18,"convertToTensor"],[69,38,56,33],[69,39,56,33,"convertToTensor"],[69,54,56,33],[69,56,56,34,"data"],[69,60,56,38],[69,62,56,40],[69,68,56,46],[69,70,56,48],[69,89,56,67],[69,90,56,68],[70,4,57,4],[70,10,57,10,"$indices"],[70,18,57,18],[70,21,57,21],[70,25,57,21,"convertToTensor"],[70,41,57,36],[70,42,57,36,"convertToTensor"],[70,57,57,36],[70,59,57,37,"indices"],[70,66,57,44],[70,68,57,46],[70,77,57,55],[70,79,57,57],[70,98,57,76],[70,100,57,78],[70,107,57,85],[70,108,57,86],[71,4,58,4],[71,10,58,10,"$segmentIds"],[71,21,58,21],[71,24,58,24],[71,28,58,24,"convertToTensor"],[71,44,58,39],[71,45,58,39,"convertToTensor"],[71,60,58,39],[71,62,58,40,"segmentIds"],[71,72,58,50],[71,74,58,52],[71,86,58,64],[71,88,58,66],[71,107,58,85],[71,109,58,87],[71,116,58,94],[71,117,58,95],[72,4,59,4],[72,8,59,8,"$data"],[72,13,59,13],[72,14,59,14,"rank"],[72,18,59,18],[72,21,59,21],[72,22,59,22],[72,24,59,24],[73,6,60,8],[73,12,60,14],[73,16,60,18,"Error"],[73,21,60,23],[73,22,60,24],[73,81,60,83],[73,82,60,84],[74,4,61,4],[75,4,62,4],[75,8,62,8,"$indices"],[75,16,62,16],[75,17,62,17,"rank"],[75,21,62,21],[75,26,62,26],[75,27,62,27],[75,29,62,29],[76,6,63,8],[76,12,63,14],[76,16,63,18,"Error"],[76,21,63,23],[76,22,63,24],[77,0,64,0],[77,12,64,12,"$indices"],[77,20,64,20],[77,21,64,21,"shape"],[77,26,64,26],[77,28,64,28],[77,29,64,29],[78,4,65,4],[79,4,66,4],[79,8,66,8,"$segmentIds"],[79,19,66,19],[79,20,66,20,"rank"],[79,24,66,24],[79,29,66,29],[79,30,66,30],[79,32,66,32],[80,6,67,8],[80,12,67,14],[80,16,67,18,"Error"],[80,21,67,23],[80,22,67,24],[81,0,68,0],[81,12,68,12,"$segmentIds"],[81,23,68,23],[81,24,68,24,"shape"],[81,29,68,29],[81,31,68,31],[81,32,68,32],[82,4,69,4],[83,4,70,4],[83,10,70,10,"inputs"],[83,16,70,16],[83,19,70,19],[84,6,71,8,"data"],[84,10,71,12],[84,12,71,14,"$data"],[84,17,71,19],[85,6,72,8,"indices"],[85,13,72,15],[85,15,72,17,"$indices"],[85,23,72,25],[86,6,73,8,"segmentIds"],[86,16,73,18],[86,18,73,20,"$segmentIds"],[87,4,74,4],[87,5,74,5],[88,4,75,4],[88,11,75,11,"ENGINE"],[88,18,75,17],[88,19,75,17,"ENGINE"],[88,25,75,17],[88,26,75,18,"runKernel"],[88,35,75,27],[88,36,75,28,"SparseSegmentMean"],[88,49,75,45],[88,50,75,45,"SparseSegmentMean"],[88,67,75,45],[88,69,75,47,"inputs"],[88,75,75,53],[88,76,75,54],[89,2,76,0],[90,2,77,7],[90,8,77,13,"sparseSegmentMean"],[90,25,77,30],[90,28,77,33],[90,43,77,49],[90,47,77,49,"op"],[90,57,77,51],[90,58,77,51,"op"],[90,60,77,51],[90,62,77,52],[91,4,77,54,"sparseSegmentMean_"],[92,2,77,73],[92,3,77,74],[92,4,77,75],[93,0,77,76],[93,3]],"functionMap":{"names":["<global>","sparseSegmentMean_"],"mappings":"AAA;ACsD;CDqB"},"hasCjsExports":false},"type":"js/module"}]}