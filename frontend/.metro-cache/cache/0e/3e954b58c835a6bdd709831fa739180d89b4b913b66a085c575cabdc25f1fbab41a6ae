{"dependencies":[{"name":"./dataset","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":18,"column":0,"index":706},"end":{"line":18,"column":50,"index":756}}],"key":"1TmPq9tq1Z6MlYHKz81li/wBs6Q=","exportNames":["*"],"imports":1}},{"name":"./datasets/csv_dataset","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":19,"column":0,"index":757},"end":{"line":19,"column":52,"index":809}}],"key":"JtuuNcX0yRBeV7ZhziYw0+/2NJg=","exportNames":["*"],"imports":1}},{"name":"./iterators/lazy_iterator","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":20,"column":0,"index":810},"end":{"line":20,"column":65,"index":875}}],"key":"30QjIozoXZtH47rEd8+EVa8kbIU=","exportNames":["*"],"imports":1}},{"name":"./iterators/microphone_iterator","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":21,"column":0,"index":876},"end":{"line":21,"column":69,"index":945}}],"key":"OpaDPsXNALK+PiYfLFhF1ScLZq4=","exportNames":["*"],"imports":1}},{"name":"./iterators/webcam_iterator","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":22,"column":0,"index":946},"end":{"line":22,"column":61,"index":1007}}],"key":"YFE4sWUK+HpyVck+zYoRt8A3AV4=","exportNames":["*"],"imports":1}},{"name":"./sources/url_data_source","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":23,"column":0,"index":1008},"end":{"line":23,"column":58,"index":1066}}],"key":"+yyCxT3Ha/B2F30beYifCvwiV8E=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  exports.csv = csv;\n  exports.func = func;\n  exports.generator = generator;\n  exports.webcam = webcam;\n  exports.microphone = microphone;\n  var _dataset = require(_dependencyMap[0], \"./dataset\");\n  var _datasetsCsv_dataset = require(_dependencyMap[1], \"./datasets/csv_dataset\");\n  var _iteratorsLazy_iterator = require(_dependencyMap[2], \"./iterators/lazy_iterator\");\n  var _iteratorsMicrophone_iterator = require(_dependencyMap[3], \"./iterators/microphone_iterator\");\n  var _iteratorsWebcam_iterator = require(_dependencyMap[4], \"./iterators/webcam_iterator\");\n  var _sourcesUrl_data_source = require(_dependencyMap[5], \"./sources/url_data_source\");\n  /**\n   * @license\n   * Copyright 2018 Google LLC. All Rights Reserved.\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * =============================================================================\n   */\n\n  /**\n   * Create a `CSVDataset` by reading and decoding CSV file(s) from provided URL\n   * or local path if it's in Node environment.\n   *\n   * Note: If isLabel in columnConfigs is `true` for at least one column, the\n   * element in returned `CSVDataset` will be an object of\n   * `{xs:features, ys:labels}`: xs is a dict of features key/value pairs, ys\n   * is a dict of labels key/value pairs. If no column is marked as label,\n   * returns a dict of features only.\n   *\n   * ```js\n   * const csvUrl =\n   * 'https://storage.googleapis.com/tfjs-examples/multivariate-linear-regression/data/boston-housing-train.csv';\n   *\n   * async function run() {\n   *   // We want to predict the column \"medv\", which represents a median value of\n   *   // a home (in $1000s), so we mark it as a label.\n   *   const csvDataset = tf.data.csv(\n   *     csvUrl, {\n   *       columnConfigs: {\n   *         medv: {\n   *           isLabel: true\n   *         }\n   *       }\n   *     });\n   *\n   *   // Number of features is the number of column names minus one for the label\n   *   // column.\n   *   const numOfFeatures = (await csvDataset.columnNames()).length - 1;\n   *\n   *   // Prepare the Dataset for training.\n   *   const flattenedDataset =\n   *     csvDataset\n   *     .map(({xs, ys}) =>\n   *       {\n   *         // Convert xs(features) and ys(labels) from object form (keyed by\n   *         // column name) to array form.\n   *         return {xs:Object.values(xs), ys:Object.values(ys)};\n   *       })\n   *     .batch(10);\n   *\n   *   // Define the model.\n   *   const model = tf.sequential();\n   *   model.add(tf.layers.dense({\n   *     inputShape: [numOfFeatures],\n   *     units: 1\n   *   }));\n   *   model.compile({\n   *     optimizer: tf.train.sgd(0.000001),\n   *     loss: 'meanSquaredError'\n   *   });\n   *\n   *   // Fit the model using the prepared Dataset\n   *   return model.fitDataset(flattenedDataset, {\n   *     epochs: 10,\n   *     callbacks: {\n   *       onEpochEnd: async (epoch, logs) => {\n   *         console.log(epoch + ':' + logs.loss);\n   *       }\n   *     }\n   *   });\n   * }\n   *\n   * await run();\n   * ```\n   *\n   * @param source URL or local path to get CSV file. If it's a local path, it\n   * must have prefix `file://` and it only works in node environment.\n   * @param csvConfig (Optional) A CSVConfig object that contains configurations\n   *     of reading and decoding from CSV file(s).\n   *\n   * @doc {\n   *   heading: 'Data',\n   *   subheading: 'Creation',\n   *   namespace: 'data',\n   *   configParamIndices: [1]\n   *  }\n   */\n  function csv(source, csvConfig = {}) {\n    return new _datasetsCsv_dataset.CSVDataset(new _sourcesUrl_data_source.URLDataSource(source), csvConfig);\n  }\n  /**\n   * Create a `Dataset` that produces each element by calling a provided function.\n   *\n   * Note that repeated iterations over this `Dataset` may produce different\n   * results, because the function will be called anew for each element of each\n   * iteration.\n   *\n   * Also, beware that the sequence of calls to this function may be out of order\n   * in time with respect to the logical order of the Dataset. This is due to the\n   * asynchronous lazy nature of stream processing, and depends on downstream\n   * transformations (e.g. .shuffle()). If the provided function is pure, this is\n   * no problem, but if it is a closure over a mutable state (e.g., a traversal\n   * pointer), then the order of the produced elements may be scrambled.\n   *\n   * ```js\n   * let i = -1;\n   * const func = () =>\n   *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n   * const ds = tf.data.func(func);\n   * await ds.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param f A function that produces one data element on each call.\n   */\n  function func(f) {\n    const iter = (0, _iteratorsLazy_iterator.iteratorFromFunction)(f);\n    return (0, _dataset.datasetFromIteratorFn)(async () => iter);\n  }\n  /**\n   * Create a `Dataset` that produces each element from provided JavaScript\n   * generator, which is a function that returns a (potentially async) iterator.\n   *\n   * For more information on iterators and generators, see\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators .\n   * For the iterator protocol, see\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols .\n   *\n   * Example of creating a dataset from an iterator factory:\n   * ```js\n   * function makeIterator() {\n   *   const numElements = 10;\n   *   let index = 0;\n   *\n   *   const iterator = {\n   *     next: () => {\n   *       let result;\n   *       if (index < numElements) {\n   *         result = {value: index, done: false};\n   *         index++;\n   *         return result;\n   *       }\n   *       return {value: index, done: true};\n   *     }\n   *   };\n   *   return iterator;\n   * }\n   * const ds = tf.data.generator(makeIterator);\n   * await ds.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * Example of creating a dataset from a generator:\n   * ```js\n   * function* dataGenerator() {\n   *   const numElements = 10;\n   *   let index = 0;\n   *   while (index < numElements) {\n   *     const x = index;\n   *     index++;\n   *     yield x;\n   *   }\n   * }\n   *\n   * const ds = tf.data.generator(dataGenerator);\n   * await ds.forEachAsync(e => console.log(e));\n   * ```\n   *\n   * @param generator A JavaScript function that returns\n   *     a (potentially async) JavaScript iterator.\n   *\n   * @doc {\n   *   heading: 'Data',\n   *   subheading: 'Creation',\n   *   namespace: 'data',\n   *   configParamIndices: [1]\n   *  }\n   */\n  function generator(generator) {\n    return (0, _dataset.datasetFromIteratorFn)(async () => {\n      const gen = await generator();\n      return (0, _iteratorsLazy_iterator.iteratorFromFunction)(() => gen.next());\n    });\n  }\n  /**\n   * Create an iterator that generates `Tensor`s from webcam video stream. This\n   * API only works in Browser environment when the device has webcam.\n   *\n   * Note: this code snippet only works when the device has a webcam. It will\n   * request permission to open the webcam when running.\n   * ```js\n   * const videoElement = document.createElement('video');\n   * videoElement.width = 100;\n   * videoElement.height = 100;\n   * const cam = await tf.data.webcam(videoElement);\n   * const img = await cam.capture();\n   * img.print();\n   * cam.stop();\n   * ```\n   *\n   * @param webcamVideoElement A `HTMLVideoElement` used to play video from\n   *     webcam. If this element is not provided, a hidden `HTMLVideoElement` will\n   *     be created. In that case, `resizeWidth` and `resizeHeight` must be\n   *     provided to set the generated tensor shape.\n   * @param webcamConfig A `WebcamConfig` object that contains configurations of\n   *     reading and manipulating data from webcam video stream.\n   *\n   * @doc {\n   *   heading: 'Data',\n   *   subheading: 'Creation',\n   *   namespace: 'data',\n   *   ignoreCI: true\n   *  }\n   */\n  async function webcam(webcamVideoElement, webcamConfig) {\n    return _iteratorsWebcam_iterator.WebcamIterator.create(webcamVideoElement, webcamConfig);\n  }\n  /**\n   * Create an iterator that generates frequency-domain spectrogram `Tensor`s from\n   * microphone audio stream with browser's native FFT. This API only works in\n   * browser environment when the device has microphone.\n   *\n   * Note: this code snippet only works when the device has a microphone. It will\n   * request permission to open the microphone when running.\n   * ```js\n   * const mic = await tf.data.microphone({\n   *   fftSize: 1024,\n   *   columnTruncateLength: 232,\n   *   numFramesPerSpectrogram: 43,\n   *   sampleRateHz:44100,\n   *   includeSpectrogram: true,\n   *   includeWaveform: true\n   * });\n   * const audioData = await mic.capture();\n   * const spectrogramTensor = audioData.spectrogram;\n   * spectrogramTensor.print();\n   * const waveformTensor = audioData.waveform;\n   * waveformTensor.print();\n   * mic.stop();\n   * ```\n   *\n   * @param microphoneConfig A `MicrophoneConfig` object that contains\n   *     configurations of reading audio data from microphone.\n   *\n   * @doc {\n   *   heading: 'Data',\n   *   subheading: 'Creation',\n   *   namespace: 'data',\n   *   ignoreCI: true\n   *  }\n   */\n  async function microphone(microphoneConfig) {\n    return _iteratorsMicrophone_iterator.MicrophoneIterator.create(microphoneConfig);\n  }\n});","lineCount":279,"map":[[7,2,102,0,"exports"],[7,9,102,0],[7,10,102,0,"csv"],[7,13,102,0],[7,16,102,0,"csv"],[7,19,102,0],[8,2,129,0,"exports"],[8,9,129,0],[8,10,129,0,"func"],[8,14,129,0],[8,17,129,0,"func"],[8,21,129,0],[9,2,191,0,"exports"],[9,9,191,0],[9,10,191,0,"generator"],[9,19,191,0],[9,22,191,0,"generator"],[9,31,191,0],[10,2,227,0,"exports"],[10,9,227,0],[10,10,227,0,"webcam"],[10,16,227,0],[10,19,227,0,"webcam"],[10,25,227,0],[11,2,264,0,"exports"],[11,9,264,0],[11,10,264,0,"microphone"],[11,20,264,0],[11,23,264,0,"microphone"],[11,33,264,0],[12,2,18,0],[12,6,18,0,"_dataset"],[12,14,18,0],[12,17,18,0,"require"],[12,24,18,0],[12,25,18,0,"_dependencyMap"],[12,39,18,0],[13,2,19,0],[13,6,19,0,"_datasetsCsv_dataset"],[13,26,19,0],[13,29,19,0,"require"],[13,36,19,0],[13,37,19,0,"_dependencyMap"],[13,51,19,0],[14,2,20,0],[14,6,20,0,"_iteratorsLazy_iterator"],[14,29,20,0],[14,32,20,0,"require"],[14,39,20,0],[14,40,20,0,"_dependencyMap"],[14,54,20,0],[15,2,21,0],[15,6,21,0,"_iteratorsMicrophone_iterator"],[15,35,21,0],[15,38,21,0,"require"],[15,45,21,0],[15,46,21,0,"_dependencyMap"],[15,60,21,0],[16,2,22,0],[16,6,22,0,"_iteratorsWebcam_iterator"],[16,31,22,0],[16,34,22,0,"require"],[16,41,22,0],[16,42,22,0,"_dependencyMap"],[16,56,22,0],[17,2,23,0],[17,6,23,0,"_sourcesUrl_data_source"],[17,29,23,0],[17,32,23,0,"require"],[17,39,23,0],[17,40,23,0,"_dependencyMap"],[17,54,23,0],[18,2,1,0],[19,0,2,0],[20,0,3,0],[21,0,4,0],[22,0,5,0],[23,0,6,0],[24,0,7,0],[25,0,8,0],[26,0,9,0],[27,0,10,0],[28,0,11,0],[29,0,12,0],[30,0,13,0],[31,0,14,0],[32,0,15,0],[33,0,16,0],[34,0,17,0],[36,2,24,0],[37,0,25,0],[38,0,26,0],[39,0,27,0],[40,0,28,0],[41,0,29,0],[42,0,30,0],[43,0,31,0],[44,0,32,0],[45,0,33,0],[46,0,34,0],[47,0,35,0],[48,0,36,0],[49,0,37,0],[50,0,38,0],[51,0,39,0],[52,0,40,0],[53,0,41,0],[54,0,42,0],[55,0,43,0],[56,0,44,0],[57,0,45,0],[58,0,46,0],[59,0,47,0],[60,0,48,0],[61,0,49,0],[62,0,50,0],[63,0,51,0],[64,0,52,0],[65,0,53,0],[66,0,54,0],[67,0,55,0],[68,0,56,0],[69,0,57,0],[70,0,58,0],[71,0,59,0],[72,0,60,0],[73,0,61,0],[74,0,62,0],[75,0,63,0],[76,0,64,0],[77,0,65,0],[78,0,66,0],[79,0,67,0],[80,0,68,0],[81,0,69,0],[82,0,70,0],[83,0,71,0],[84,0,72,0],[85,0,73,0],[86,0,74,0],[87,0,75,0],[88,0,76,0],[89,0,77,0],[90,0,78,0],[91,0,79,0],[92,0,80,0],[93,0,81,0],[94,0,82,0],[95,0,83,0],[96,0,84,0],[97,0,85,0],[98,0,86,0],[99,0,87,0],[100,0,88,0],[101,0,89,0],[102,0,90,0],[103,0,91,0],[104,0,92,0],[105,0,93,0],[106,0,94,0],[107,0,95,0],[108,0,96,0],[109,0,97,0],[110,0,98,0],[111,0,99,0],[112,0,100,0],[113,0,101,0],[114,2,102,7],[114,11,102,16,"csv"],[114,14,102,19,"csv"],[114,15,102,20,"source"],[114,21,102,26],[114,23,102,28,"csvConfig"],[114,32,102,37],[114,35,102,40],[114,36,102,41],[114,37,102,42],[114,39,102,44],[115,4,103,4],[115,11,103,11],[115,15,103,15,"CSVDataset"],[115,35,103,25],[115,36,103,25,"CSVDataset"],[115,46,103,25],[115,47,103,26],[115,51,103,30,"URLDataSource"],[115,74,103,43],[115,75,103,43,"URLDataSource"],[115,88,103,43],[115,89,103,44,"source"],[115,95,103,50],[115,96,103,51],[115,98,103,53,"csvConfig"],[115,107,103,62],[115,108,103,63],[116,2,104,0],[117,2,105,0],[118,0,106,0],[119,0,107,0],[120,0,108,0],[121,0,109,0],[122,0,110,0],[123,0,111,0],[124,0,112,0],[125,0,113,0],[126,0,114,0],[127,0,115,0],[128,0,116,0],[129,0,117,0],[130,0,118,0],[131,0,119,0],[132,0,120,0],[133,0,121,0],[134,0,122,0],[135,0,123,0],[136,0,124,0],[137,0,125,0],[138,0,126,0],[139,0,127,0],[140,0,128,0],[141,2,129,7],[141,11,129,16,"func"],[141,15,129,20,"func"],[141,16,129,21,"f"],[141,17,129,22],[141,19,129,24],[142,4,130,4],[142,10,130,10,"iter"],[142,14,130,14],[142,17,130,17],[142,21,130,17,"iteratorFromFunction"],[142,44,130,37],[142,45,130,37,"iteratorFromFunction"],[142,65,130,37],[142,67,130,38,"f"],[142,68,130,39],[142,69,130,40],[143,4,131,4],[143,11,131,11],[143,15,131,11,"datasetFromIteratorFn"],[143,23,131,32],[143,24,131,32,"datasetFromIteratorFn"],[143,45,131,32],[143,47,131,33],[143,59,131,45,"iter"],[143,63,131,49],[143,64,131,50],[144,2,132,0],[145,2,133,0],[146,0,134,0],[147,0,135,0],[148,0,136,0],[149,0,137,0],[150,0,138,0],[151,0,139,0],[152,0,140,0],[153,0,141,0],[154,0,142,0],[155,0,143,0],[156,0,144,0],[157,0,145,0],[158,0,146,0],[159,0,147,0],[160,0,148,0],[161,0,149,0],[162,0,150,0],[163,0,151,0],[164,0,152,0],[165,0,153,0],[166,0,154,0],[167,0,155,0],[168,0,156,0],[169,0,157,0],[170,0,158,0],[171,0,159,0],[172,0,160,0],[173,0,161,0],[174,0,162,0],[175,0,163,0],[176,0,164,0],[177,0,165,0],[178,0,166,0],[179,0,167,0],[180,0,168,0],[181,0,169,0],[182,0,170,0],[183,0,171,0],[184,0,172,0],[185,0,173,0],[186,0,174,0],[187,0,175,0],[188,0,176,0],[189,0,177,0],[190,0,178,0],[191,0,179,0],[192,0,180,0],[193,0,181,0],[194,0,182,0],[195,0,183,0],[196,0,184,0],[197,0,185,0],[198,0,186,0],[199,0,187,0],[200,0,188,0],[201,0,189,0],[202,0,190,0],[203,2,191,7],[203,11,191,16,"generator"],[203,20,191,25,"generator"],[203,21,191,26,"generator"],[203,30,191,35],[203,32,191,37],[204,4,192,4],[204,11,192,11],[204,15,192,11,"datasetFromIteratorFn"],[204,23,192,32],[204,24,192,32,"datasetFromIteratorFn"],[204,45,192,32],[204,47,192,33],[204,59,192,45],[205,6,193,8],[205,12,193,14,"gen"],[205,15,193,17],[205,18,193,20],[205,24,193,26,"generator"],[205,33,193,35],[205,34,193,36],[205,35,193,37],[206,6,194,8],[206,13,194,15],[206,17,194,15,"iteratorFromFunction"],[206,40,194,35],[206,41,194,35,"iteratorFromFunction"],[206,61,194,35],[206,63,194,36],[206,69,194,42,"gen"],[206,72,194,45],[206,73,194,46,"next"],[206,77,194,50],[206,78,194,51],[206,79,194,52],[206,80,194,53],[207,4,195,4],[207,5,195,5],[207,6,195,6],[208,2,196,0],[209,2,197,0],[210,0,198,0],[211,0,199,0],[212,0,200,0],[213,0,201,0],[214,0,202,0],[215,0,203,0],[216,0,204,0],[217,0,205,0],[218,0,206,0],[219,0,207,0],[220,0,208,0],[221,0,209,0],[222,0,210,0],[223,0,211,0],[224,0,212,0],[225,0,213,0],[226,0,214,0],[227,0,215,0],[228,0,216,0],[229,0,217,0],[230,0,218,0],[231,0,219,0],[232,0,220,0],[233,0,221,0],[234,0,222,0],[235,0,223,0],[236,0,224,0],[237,0,225,0],[238,0,226,0],[239,2,227,7],[239,17,227,22,"webcam"],[239,23,227,28,"webcam"],[239,24,227,29,"webcamVideoElement"],[239,42,227,47],[239,44,227,49,"webcamConfig"],[239,56,227,61],[239,58,227,63],[240,4,228,4],[240,11,228,11,"WebcamIterator"],[240,36,228,25],[240,37,228,25,"WebcamIterator"],[240,51,228,25],[240,52,228,26,"create"],[240,58,228,32],[240,59,228,33,"webcamVideoElement"],[240,77,228,51],[240,79,228,53,"webcamConfig"],[240,91,228,65],[240,92,228,66],[241,2,229,0],[242,2,230,0],[243,0,231,0],[244,0,232,0],[245,0,233,0],[246,0,234,0],[247,0,235,0],[248,0,236,0],[249,0,237,0],[250,0,238,0],[251,0,239,0],[252,0,240,0],[253,0,241,0],[254,0,242,0],[255,0,243,0],[256,0,244,0],[257,0,245,0],[258,0,246,0],[259,0,247,0],[260,0,248,0],[261,0,249,0],[262,0,250,0],[263,0,251,0],[264,0,252,0],[265,0,253,0],[266,0,254,0],[267,0,255,0],[268,0,256,0],[269,0,257,0],[270,0,258,0],[271,0,259,0],[272,0,260,0],[273,0,261,0],[274,0,262,0],[275,0,263,0],[276,2,264,7],[276,17,264,22,"microphone"],[276,27,264,32,"microphone"],[276,28,264,33,"microphoneConfig"],[276,44,264,49],[276,46,264,51],[277,4,265,4],[277,11,265,11,"MicrophoneIterator"],[277,40,265,29],[277,41,265,29,"MicrophoneIterator"],[277,59,265,29],[277,60,265,30,"create"],[277,66,265,36],[277,67,265,37,"microphoneConfig"],[277,83,265,53],[277,84,265,54],[278,2,266,0],[279,0,266,1],[279,3]],"functionMap":{"names":["<global>","csv","func","datasetFromIteratorFn$argument_0","generator","iteratorFromFunction$argument_0","webcam","microphone"],"mappings":"AAA;OCqG;CDE;OEyB;iCCE,gBD;CFC;OI2D;iCDC;oCEE,gBF;KCC;CJC;OM+B;CNE;OOmC;CPE"},"hasCjsExports":false},"type":"js/module"}]}