{"dependencies":[{"name":"../../tensor_util_env","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":17,"column":0,"index":703},"end":{"line":17,"column":56,"index":759}}],"key":"xfSGNGkCJdZhfQ673y/6d+no2yU=","exportNames":["*"],"imports":1}},{"name":"../../util","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":18,"column":0,"index":760},"end":{"line":18,"column":47,"index":807}}],"key":"OiLVMoS12Mp3xgHkQeTdnQIBX6Q=","exportNames":["*"],"imports":1}},{"name":"../abs","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":19,"column":0,"index":808},"end":{"line":19,"column":29,"index":837}}],"key":"Nl0FY0FYJAJat87d2xJ8W/Uz/QE=","exportNames":["*"],"imports":1}},{"name":"../add","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":20,"column":0,"index":838},"end":{"line":20,"column":29,"index":867}}],"key":"S+ID0fW8sc9iwSUS6COac9En52o=","exportNames":["*"],"imports":1}},{"name":"../exp","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":21,"column":0,"index":868},"end":{"line":21,"column":29,"index":897}}],"key":"zCudubqQh0dHkLaVIX2qSxH207c=","exportNames":["*"],"imports":1}},{"name":"../log1p","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":22,"column":0,"index":898},"end":{"line":22,"column":33,"index":931}}],"key":"99ASLsLzB4uuZw9xhPb7b3XsujE=","exportNames":["*"],"imports":1}},{"name":"../loss_ops_utils","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":23,"column":0,"index":932},"end":{"line":23,"column":46,"index":978}}],"key":"DAPyQ0ldu7pmRn3jRz+wBfmq/uQ=","exportNames":["*"],"imports":1}},{"name":"../mul","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":24,"column":0,"index":979},"end":{"line":24,"column":29,"index":1008}}],"key":"IV74B7MBUPoSZUTM5ocGXe9fIRE=","exportNames":["*"],"imports":1}},{"name":"../neg","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":25,"column":0,"index":1009},"end":{"line":25,"column":29,"index":1038}}],"key":"dIvRqtCbdaqqXK829v9NQbmYkxI=","exportNames":["*"],"imports":1}},{"name":"../operation","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":26,"column":0,"index":1039},"end":{"line":26,"column":34,"index":1073}}],"key":"fQilPqfSvhAHjyfKT0P4wel7jE4=","exportNames":["*"],"imports":1}},{"name":"../relu","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":27,"column":0,"index":1074},"end":{"line":27,"column":31,"index":1105}}],"key":"/b5XZF1raYdGkxO3BUEKjJ7sgLI=","exportNames":["*"],"imports":1}},{"name":"../scalar","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":28,"column":0,"index":1106},"end":{"line":28,"column":35,"index":1141}}],"key":"u3TTm6Tdu30WLt+AMD6qMWu+U20=","exportNames":["*"],"imports":1}},{"name":"../sub","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":29,"column":0,"index":1142},"end":{"line":29,"column":29,"index":1171}}],"key":"VHM5JuAkEzgPhqMJH9y/GvrNozc=","exportNames":["*"],"imports":1}},{"name":"./compute_weighted_loss","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":30,"column":0,"index":1172},"end":{"line":30,"column":62,"index":1234}}],"key":"GQ6sNEw27lLpLYC7mByWPpwMOcY=","exportNames":["*"],"imports":1}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  \"use strict\";\n\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n  Object.defineProperty(exports, \"sigmoidCrossEntropy\", {\n    enumerable: true,\n    get: function () {\n      return sigmoidCrossEntropy;\n    }\n  });\n  var _tensor_util_env = require(_dependencyMap[0], \"../../tensor_util_env\");\n  var _util = require(_dependencyMap[1], \"../../util\");\n  var _abs = require(_dependencyMap[2], \"../abs\");\n  var _add = require(_dependencyMap[3], \"../add\");\n  var _exp = require(_dependencyMap[4], \"../exp\");\n  var _log1p = require(_dependencyMap[5], \"../log1p\");\n  var _loss_ops_utils = require(_dependencyMap[6], \"../loss_ops_utils\");\n  var _mul = require(_dependencyMap[7], \"../mul\");\n  var _neg = require(_dependencyMap[8], \"../neg\");\n  var _operation = require(_dependencyMap[9], \"../operation\");\n  var _relu = require(_dependencyMap[10], \"../relu\");\n  var _scalar = require(_dependencyMap[11], \"../scalar\");\n  var _sub = require(_dependencyMap[12], \"../sub\");\n  var _compute_weighted_loss = require(_dependencyMap[13], \"./compute_weighted_loss\");\n  /**\n   * @license\n   * Copyright 2020 Google LLC. All Rights Reserved.\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   * =============================================================================\n   */\n\n  function sigmoidCrossEntropyWithLogits_(labels, logits) {\n    const $labels = (0, _tensor_util_env.convertToTensor)(labels, 'labels', 'sigmoidCrossEntropyWithLogits');\n    const $logits = (0, _tensor_util_env.convertToTensor)(logits, 'logits', 'sigmoidCrossEntropyWithLogits');\n    (0, _util.assertShapesMatch)($labels.shape, $logits.shape, 'Error in sigmoidCrossEntropyWithLogits: ');\n    /**\n     * Implementation Details:\n     *\n     * For brevity, let `x = logits`, `z = labels`.  The logistic loss is\n     *     z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))\n     *   = z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))\n     *   = z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))\n     *   = z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))\n     *   = (1 - z) * x + log(1 + exp(-x))\n     *   = x - x * z + log(1 + exp(-x))\n     *\n     *   For x < 0, to avoid overflow in exp(-x), we reformulate the above\n     *     x - x * z + log(1 + exp(-x))\n     *   = log(exp(x)) - x * z + log(1 + exp(-x))\n     *   = - x * z + log(1 + exp(x))\n     *\n     * Hence, to ensure stability and avoid overflow, the implementation uses\n     * this equivalent formulation:\n     *     max(x, 0) - x * z + log(1 + exp(-abs(x)))\n     */\n    const maxOutput = (0, _relu.relu)($logits);\n    const outputXTarget = (0, _mul.mul)($logits, $labels);\n    const sigmoidOutput = (0, _log1p.log1p)((0, _exp.exp)((0, _neg.neg)((0, _abs.abs)($logits))));\n    return (0, _add.add)((0, _sub.sub)(maxOutput, outputXTarget), sigmoidOutput);\n  }\n  /**\n   * Computes the sigmoid cross entropy loss between two tensors.\n   *\n   * If labelSmoothing is nonzero, smooth the labels towards 1/2:\n   *\n   *   newMulticlassLabels = multiclassLabels * (1 - labelSmoothing)\n   *                         + 0.5 * labelSmoothing\n   *\n   * @param multiClassLabels The ground truth output tensor of shape\n   * [batch_size, num_classes], same dimensions as 'predictions'.\n   * @param logits The predicted outputs.\n   * @param weights Tensor whose rank is either 0, or the same rank as\n   *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n   *    must be either `1`, or the same as the corresponding `losses`\n   *    dimension).\n   * @param labelSmoothing If greater than 0, then smooth the labels.\n   * @param reduction Type of reduction to apply to loss. Should be of type\n   *    `Reduction`\n   *\n   * @doc { heading: 'Training', subheading: 'Losses', namespace: 'losses' }\n   */\n  function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing = 0, reduction = _loss_ops_utils.Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    let $multiClassLabels = (0, _tensor_util_env.convertToTensor)(multiClassLabels, 'multiClassLabels', 'sigmoidCrossEntropy');\n    const $logits = (0, _tensor_util_env.convertToTensor)(logits, 'logits', 'sigmoidCrossEntropy');\n    let $weights = null;\n    if (weights != null) {\n      $weights = (0, _tensor_util_env.convertToTensor)(weights, 'weights', 'sigmoidCrossEntropy');\n    }\n    (0, _util.assertShapesMatch)($multiClassLabels.shape, $logits.shape, 'Error in sigmoidCrossEntropy: ');\n    if (labelSmoothing > 0) {\n      const labelSmoothingScalar = (0, _scalar.scalar)(labelSmoothing);\n      const one = (0, _scalar.scalar)(1);\n      const half = (0, _scalar.scalar)(0.5);\n      $multiClassLabels = (0, _add.add)((0, _mul.mul)($multiClassLabels, (0, _sub.sub)(one, labelSmoothingScalar)), (0, _mul.mul)(half, labelSmoothingScalar));\n    }\n    const losses = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);\n    return (0, _compute_weighted_loss.computeWeightedLoss)(losses, $weights, reduction);\n  }\n  const sigmoidCrossEntropy = /* @__PURE__ */(0, _operation.op)({\n    sigmoidCrossEntropy_\n  });\n});","lineCount":114,"map":[[7,2,99,0,"Object"],[7,8,99,0],[7,9,99,0,"defineProperty"],[7,23,99,0],[7,24,99,0,"exports"],[7,31,99,0],[8,4,99,0,"enumerable"],[8,14,99,0],[9,4,99,0,"get"],[9,7,99,0],[9,18,99,0,"get"],[9,19,99,0],[10,6,99,0],[10,13,99,0,"sigmoidCrossEntropy"],[10,32,99,0],[11,4,99,0],[12,2,99,0],[13,2,17,0],[13,6,17,0,"_tensor_util_env"],[13,22,17,0],[13,25,17,0,"require"],[13,32,17,0],[13,33,17,0,"_dependencyMap"],[13,47,17,0],[14,2,18,0],[14,6,18,0,"_util"],[14,11,18,0],[14,14,18,0,"require"],[14,21,18,0],[14,22,18,0,"_dependencyMap"],[14,36,18,0],[15,2,19,0],[15,6,19,0,"_abs"],[15,10,19,0],[15,13,19,0,"require"],[15,20,19,0],[15,21,19,0,"_dependencyMap"],[15,35,19,0],[16,2,20,0],[16,6,20,0,"_add"],[16,10,20,0],[16,13,20,0,"require"],[16,20,20,0],[16,21,20,0,"_dependencyMap"],[16,35,20,0],[17,2,21,0],[17,6,21,0,"_exp"],[17,10,21,0],[17,13,21,0,"require"],[17,20,21,0],[17,21,21,0,"_dependencyMap"],[17,35,21,0],[18,2,22,0],[18,6,22,0,"_log1p"],[18,12,22,0],[18,15,22,0,"require"],[18,22,22,0],[18,23,22,0,"_dependencyMap"],[18,37,22,0],[19,2,23,0],[19,6,23,0,"_loss_ops_utils"],[19,21,23,0],[19,24,23,0,"require"],[19,31,23,0],[19,32,23,0,"_dependencyMap"],[19,46,23,0],[20,2,24,0],[20,6,24,0,"_mul"],[20,10,24,0],[20,13,24,0,"require"],[20,20,24,0],[20,21,24,0,"_dependencyMap"],[20,35,24,0],[21,2,25,0],[21,6,25,0,"_neg"],[21,10,25,0],[21,13,25,0,"require"],[21,20,25,0],[21,21,25,0,"_dependencyMap"],[21,35,25,0],[22,2,26,0],[22,6,26,0,"_operation"],[22,16,26,0],[22,19,26,0,"require"],[22,26,26,0],[22,27,26,0,"_dependencyMap"],[22,41,26,0],[23,2,27,0],[23,6,27,0,"_relu"],[23,11,27,0],[23,14,27,0,"require"],[23,21,27,0],[23,22,27,0,"_dependencyMap"],[23,36,27,0],[24,2,28,0],[24,6,28,0,"_scalar"],[24,13,28,0],[24,16,28,0,"require"],[24,23,28,0],[24,24,28,0,"_dependencyMap"],[24,38,28,0],[25,2,29,0],[25,6,29,0,"_sub"],[25,10,29,0],[25,13,29,0,"require"],[25,20,29,0],[25,21,29,0,"_dependencyMap"],[25,35,29,0],[26,2,30,0],[26,6,30,0,"_compute_weighted_loss"],[26,28,30,0],[26,31,30,0,"require"],[26,38,30,0],[26,39,30,0,"_dependencyMap"],[26,53,30,0],[27,2,1,0],[28,0,2,0],[29,0,3,0],[30,0,4,0],[31,0,5,0],[32,0,6,0],[33,0,7,0],[34,0,8,0],[35,0,9,0],[36,0,10,0],[37,0,11,0],[38,0,12,0],[39,0,13,0],[40,0,14,0],[41,0,15,0],[42,0,16,0],[44,2,31,0],[44,11,31,9,"sigmoidCrossEntropyWithLogits_"],[44,41,31,39,"sigmoidCrossEntropyWithLogits_"],[44,42,31,40,"labels"],[44,48,31,46],[44,50,31,48,"logits"],[44,56,31,54],[44,58,31,56],[45,4,32,4],[45,10,32,10,"$labels"],[45,17,32,17],[45,20,32,20],[45,24,32,20,"convertToTensor"],[45,40,32,35],[45,41,32,35,"convertToTensor"],[45,56,32,35],[45,58,32,36,"labels"],[45,64,32,42],[45,66,32,44],[45,74,32,52],[45,76,32,54],[45,107,32,85],[45,108,32,86],[46,4,33,4],[46,10,33,10,"$logits"],[46,17,33,17],[46,20,33,20],[46,24,33,20,"convertToTensor"],[46,40,33,35],[46,41,33,35,"convertToTensor"],[46,56,33,35],[46,58,33,36,"logits"],[46,64,33,42],[46,66,33,44],[46,74,33,52],[46,76,33,54],[46,107,33,85],[46,108,33,86],[47,4,34,4],[47,8,34,4,"assertShapesMatch"],[47,13,34,21],[47,14,34,21,"assertShapesMatch"],[47,31,34,21],[47,33,34,22,"$labels"],[47,40,34,29],[47,41,34,30,"shape"],[47,46,34,35],[47,48,34,37,"$logits"],[47,55,34,44],[47,56,34,45,"shape"],[47,61,34,50],[47,63,34,52],[47,105,34,94],[47,106,34,95],[48,4,35,4],[49,0,36,0],[50,0,37,0],[51,0,38,0],[52,0,39,0],[53,0,40,0],[54,0,41,0],[55,0,42,0],[56,0,43,0],[57,0,44,0],[58,0,45,0],[59,0,46,0],[60,0,47,0],[61,0,48,0],[62,0,49,0],[63,0,50,0],[64,0,51,0],[65,0,52,0],[66,0,53,0],[67,0,54,0],[68,4,55,4],[68,10,55,10,"maxOutput"],[68,19,55,19],[68,22,55,22],[68,26,55,22,"relu"],[68,31,55,26],[68,32,55,26,"relu"],[68,36,55,26],[68,38,55,27,"$logits"],[68,45,55,34],[68,46,55,35],[69,4,56,4],[69,10,56,10,"outputXTarget"],[69,23,56,23],[69,26,56,26],[69,30,56,26,"mul"],[69,34,56,29],[69,35,56,29,"mul"],[69,38,56,29],[69,40,56,30,"$logits"],[69,47,56,37],[69,49,56,39,"$labels"],[69,56,56,46],[69,57,56,47],[70,4,57,4],[70,10,57,10,"sigmoidOutput"],[70,23,57,23],[70,26,57,26],[70,30,57,26,"log1p"],[70,36,57,31],[70,37,57,31,"log1p"],[70,42,57,31],[70,44,57,32],[70,48,57,32,"exp"],[70,52,57,35],[70,53,57,35,"exp"],[70,56,57,35],[70,58,57,36],[70,62,57,36,"neg"],[70,66,57,39],[70,67,57,39,"neg"],[70,70,57,39],[70,72,57,40],[70,76,57,40,"abs"],[70,80,57,43],[70,81,57,43,"abs"],[70,84,57,43],[70,86,57,44,"$logits"],[70,93,57,51],[70,94,57,52],[70,95,57,53],[70,96,57,54],[70,97,57,55],[71,4,58,4],[71,11,58,11],[71,15,58,11,"add"],[71,19,58,14],[71,20,58,14,"add"],[71,23,58,14],[71,25,58,15],[71,29,58,15,"sub"],[71,33,58,18],[71,34,58,18,"sub"],[71,37,58,18],[71,39,58,19,"maxOutput"],[71,48,58,28],[71,50,58,30,"outputXTarget"],[71,63,58,43],[71,64,58,44],[71,66,58,46,"sigmoidOutput"],[71,79,58,59],[71,80,58,60],[72,2,59,0],[73,2,60,0],[74,0,61,0],[75,0,62,0],[76,0,63,0],[77,0,64,0],[78,0,65,0],[79,0,66,0],[80,0,67,0],[81,0,68,0],[82,0,69,0],[83,0,70,0],[84,0,71,0],[85,0,72,0],[86,0,73,0],[87,0,74,0],[88,0,75,0],[89,0,76,0],[90,0,77,0],[91,0,78,0],[92,0,79,0],[93,0,80,0],[94,2,81,0],[94,11,81,9,"sigmoidCrossEntropy_"],[94,31,81,29,"sigmoidCrossEntropy_"],[94,32,81,30,"multiClassLabels"],[94,48,81,46],[94,50,81,48,"logits"],[94,56,81,54],[94,58,81,56,"weights"],[94,65,81,63],[94,67,81,65,"labelSmoothing"],[94,81,81,79],[94,84,81,82],[94,85,81,83],[94,87,81,85,"reduction"],[94,96,81,94],[94,99,81,97,"Reduction"],[94,114,81,106],[94,115,81,106,"Reduction"],[94,124,81,106],[94,125,81,107,"SUM_BY_NONZERO_WEIGHTS"],[94,147,81,129],[94,149,81,131],[95,4,82,4],[95,8,82,8,"$multiClassLabels"],[95,25,82,25],[95,28,82,28],[95,32,82,28,"convertToTensor"],[95,48,82,43],[95,49,82,43,"convertToTensor"],[95,64,82,43],[95,66,82,44,"multiClassLabels"],[95,82,82,60],[95,84,82,62],[95,102,82,80],[95,104,82,82],[95,125,82,103],[95,126,82,104],[96,4,83,4],[96,10,83,10,"$logits"],[96,17,83,17],[96,20,83,20],[96,24,83,20,"convertToTensor"],[96,40,83,35],[96,41,83,35,"convertToTensor"],[96,56,83,35],[96,58,83,36,"logits"],[96,64,83,42],[96,66,83,44],[96,74,83,52],[96,76,83,54],[96,97,83,75],[96,98,83,76],[97,4,84,4],[97,8,84,8,"$weights"],[97,16,84,16],[97,19,84,19],[97,23,84,23],[98,4,85,4],[98,8,85,8,"weights"],[98,15,85,15],[98,19,85,19],[98,23,85,23],[98,25,85,25],[99,6,86,8,"$weights"],[99,14,86,16],[99,17,86,19],[99,21,86,19,"convertToTensor"],[99,37,86,34],[99,38,86,34,"convertToTensor"],[99,53,86,34],[99,55,86,35,"weights"],[99,62,86,42],[99,64,86,44],[99,73,86,53],[99,75,86,55],[99,96,86,76],[99,97,86,77],[100,4,87,4],[101,4,88,4],[101,8,88,4,"assertShapesMatch"],[101,13,88,21],[101,14,88,21,"assertShapesMatch"],[101,31,88,21],[101,33,88,22,"$multiClassLabels"],[101,50,88,39],[101,51,88,40,"shape"],[101,56,88,45],[101,58,88,47,"$logits"],[101,65,88,54],[101,66,88,55,"shape"],[101,71,88,60],[101,73,88,62],[101,105,88,94],[101,106,88,95],[102,4,89,4],[102,8,89,8,"labelSmoothing"],[102,22,89,22],[102,25,89,25],[102,26,89,26],[102,28,89,28],[103,6,90,8],[103,12,90,14,"labelSmoothingScalar"],[103,32,90,34],[103,35,90,37],[103,39,90,37,"scalar"],[103,46,90,43],[103,47,90,43,"scalar"],[103,53,90,43],[103,55,90,44,"labelSmoothing"],[103,69,90,58],[103,70,90,59],[104,6,91,8],[104,12,91,14,"one"],[104,15,91,17],[104,18,91,20],[104,22,91,20,"scalar"],[104,29,91,26],[104,30,91,26,"scalar"],[104,36,91,26],[104,38,91,27],[104,39,91,28],[104,40,91,29],[105,6,92,8],[105,12,92,14,"half"],[105,16,92,18],[105,19,92,21],[105,23,92,21,"scalar"],[105,30,92,27],[105,31,92,27,"scalar"],[105,37,92,27],[105,39,92,28],[105,42,92,31],[105,43,92,32],[106,6,93,8,"$multiClassLabels"],[106,23,93,25],[106,26,94,12],[106,30,94,12,"add"],[106,34,94,15],[106,35,94,15,"add"],[106,38,94,15],[106,40,94,16],[106,44,94,16,"mul"],[106,48,94,19],[106,49,94,19,"mul"],[106,52,94,19],[106,54,94,20,"$multiClassLabels"],[106,71,94,37],[106,73,94,39],[106,77,94,39,"sub"],[106,81,94,42],[106,82,94,42,"sub"],[106,85,94,42],[106,87,94,43,"one"],[106,90,94,46],[106,92,94,48,"labelSmoothingScalar"],[106,112,94,68],[106,113,94,69],[106,114,94,70],[106,116,94,72],[106,120,94,72,"mul"],[106,124,94,75],[106,125,94,75,"mul"],[106,128,94,75],[106,130,94,76,"half"],[106,134,94,80],[106,136,94,82,"labelSmoothingScalar"],[106,156,94,102],[106,157,94,103],[106,158,94,104],[107,4,95,4],[108,4,96,4],[108,10,96,10,"losses"],[108,16,96,16],[108,19,96,19,"sigmoidCrossEntropyWithLogits_"],[108,49,96,49],[108,50,96,50,"$multiClassLabels"],[108,67,96,67],[108,69,96,69,"$logits"],[108,76,96,76],[108,77,96,77],[109,4,97,4],[109,11,97,11],[109,15,97,11,"computeWeightedLoss"],[109,37,97,30],[109,38,97,30,"computeWeightedLoss"],[109,57,97,30],[109,59,97,31,"losses"],[109,65,97,37],[109,67,97,39,"$weights"],[109,75,97,47],[109,77,97,49,"reduction"],[109,86,97,58],[109,87,97,59],[110,2,98,0],[111,2,99,7],[111,8,99,13,"sigmoidCrossEntropy"],[111,27,99,32],[111,30,99,35],[111,45,99,51],[111,49,99,51,"op"],[111,59,99,53],[111,60,99,53,"op"],[111,62,99,53],[111,64,99,54],[112,4,99,56,"sigmoidCrossEntropy_"],[113,2,99,77],[113,3,99,78],[113,4,99,79],[114,0,99,80],[114,3]],"functionMap":{"names":["<global>","sigmoidCrossEntropyWithLogits_","sigmoidCrossEntropy_"],"mappings":"AAA;AC8B;CD4B;AEsB;CFiB"},"hasCjsExports":false},"type":"js/module"}]}